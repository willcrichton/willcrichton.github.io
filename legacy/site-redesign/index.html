<!DOCTYPE html>
    <html lang='en-US'>
      <head>
        <link rel="stylesheet" type="text/css" href="/legacy/site-redesign/assets/static/index.B6B538W5.css">
        <link rel="stylesheet" type="text/css" href="/legacy/site-redesign/assets/static/index.CojxvQHj.css">
        <link rel="preload" href="/legacy/site-redesign/assets/static/LinLibertine_R.CeEMES0m.woff" as="font" type="font/woff" crossorigin>
        <link rel="preload" href="/legacy/site-redesign/assets/static/LinLibertine_RI.B_z6UIzw.woff" as="font" type="font/woff" crossorigin>
        <link rel="preload" href="/legacy/site-redesign/assets/static/LinLibertine_RB.C8Bc41wt.woff" as="font" type="font/woff" crossorigin>
        <link rel="preload" href="/legacy/site-redesign/assets/static/LinLibertine_DR.D8XrRhZW.woff" as="font" type="font/woff" crossorigin>
        <link rel="preload" href="/legacy/site-redesign/assets/static/LinBiolinum_R.B1kCN6uZ.woff" as="font" type="font/woff" crossorigin>
        <link rel="preload" href="/legacy/site-redesign/assets/static/LinBiolinum_RI.CxxBaQ2E.woff" as="font" type="font/woff" crossorigin>
        <link rel="preload" href="/legacy/site-redesign/assets/static/LinBiolinum_RB.BIv4_vyH.woff" as="font" type="font/woff" crossorigin>
        <meta charset="UTF-8" />
        <title>Will Crichton</title>
        <meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
        
      </head>
      <body>
        <div id="react-root"><div id="root"><div><h1>Will Crichton</h1><p>[bio goes here]</p><div id="research-garden"><h2>Research Garden<!-- --> <button>[<!-- -->+<!-- -->]</button></h2><p><i>This is where I grow my research ideas.</i></p><div></div><section><h3>Technologies</h3><p><em>Research interests focused on a particular system or language.</em></p><details><summary><h4>A new era of systems programming with Rust</h4></summary><section><h5>Motivation</h5><p>Rust is one of the most exciting developments in programming languages in the last 15 years. This is for two reasons:</p><ol><li><p>Rust <q>solves</q> the issue of memory safety without garbage collection. This makes both <abbr>PL</abbr> theorists and security engineers happy.</p></li><li><p><em>Way more importantly,</em> Rust makes both systems programming and functional programming accessible to a broad audience. This is true because (a) Rust has extremely good tooling, (b) Rust avoids much of the accumulated complexity of C++, and (c) Rust was designed by someone who cares about <abbr>PL</abbr> theory.</p></li></ol><p>Rust is taking great ideas in <abbr>PL</abbr> (e.g., type classes, algebraic data types, expression-oriented programming) that have been stewing for 30+ years in languages like OCaml and Haskell, and Rust is finally bringing these concepts into the limelight. As a result, people are using Rust to totally rethink the design of systems:<!-- --> <a href="https://bevyengine.org/">game engines</a>,<!-- --> <a href="https://rocket.rs/">web servers</a>,<!-- --> <a href="https://github.com/linebender/xilem"><abbr>2D</abbr> graphics</a>, <a href="https://github.com/rustls/rustls">cryptography</a>,<!-- --> <a href="https://docs.rs/nalgebra/latest/nalgebra/">linear algebra</a>,<!-- --> <a href="http://serde.rs/">serialization</a>,<!-- --> <a href="https://lib.rs/crates/nom">parsing</a>, and even<!-- --> <a href="https://doc.rust-lang.org/std/string/struct.String.html">string <abbr>API</abbr>s</a> <!-- -->(just to name a few!).</p></section><section><h5>My angle</h5><p>I have main two research angles on Rust:</p><ol><li><p><strong>How can people learn and use Rust more effectively?</strong> <!-- -->Rust is a complex language. People need help to both ramp up into that complexity when learning, and to manage that complexity when programming.</p><ul><li><p>I have been running a long-term experiment on<!-- --> <a href="https://rust-book.cs.brown.edu/">a fork of the Rust Book</a> <!-- -->to evaluate methods for teaching Rust.<!-- --> <q><a href="#ownership-conceptual-model">A Grounded Conceptual Model for Ownership Types in Rust</a></q> <!-- -->(<abbr>OOPSLA</abbr> 2023) describes a new way to think about Rust&#x27;s ownership system as embodied in the<!-- --> <a href="https://cognitive-engineering-lab.github.io/aquascope">Aquascope</a> <!-- -->visualizer.<!-- --> <q><a href="#profiling-learning">Profiling Programming Language Learning</a></q> <!-- -->(<abbr>OOPSLA</abbr> 2024) describes how we embedded quizzes into the book to both figure out which concepts were hardest for learners, and to evaluate interventions in the book.</p></li><li><p>I created the<!-- --> <a href="https://github.com/willcrichton/flowistry/">Flowistry program slicer</a> <!-- -->for Rust. Flowistry helps Rust programmers read complex code by visualizing which code depends on a given expression.<!-- --> <q><a href="#flowistry">Modular Information Flow through Ownership</a></q> <!-- -->(<abbr>PLDI</abbr> 2022) describes how Flowistry uses Rust&#x27;s ownership types in a clever way to understand how functions induce dependencies just by their type signature.</p></li></ul></li><li><p><strong>How can we use Rust&#x27;s features to design systems that are safer, faster, more correct, and more usable?</strong> <!-- -->Because Rust&#x27;s feature set is so different from traditional<!-- --> <abbr>OOP</abbr>languages, it&#x27;s a big open question how systems should be architected in Rust.</p><ul><li><p>I want to systematize the process of mapping from conceptual objects to concrete APIs. What kinds of concepts should you encode as traits? As enums? And so on. I wrote<q><a href="#rust-design-patterns">Typed Design Patterns for the Functional Era</a></q> <!-- -->(<abbr>FUNARCH @ ICFP</abbr> 2023) as a first step in this direction.</p></li><li>Not really for research, but I&#x27;ve built a lot of Rust<!-- --> <abbr>API</abbr>s like<!-- --> <a href="https://github.com/willcrichton/indexical">indexed collections</a>,<!-- --> <a href="https://github.com/willcrichton/web-logger">browser-based logging</a>, and<!-- --> <a href="https://github.com/willcrichton/rlu-rs">lock-free data structures</a>.</li></ul></li></ol></section><section><h5>Project ideas</h5><ol><li><p>Could you design a higher-level language on top of Rust (imagine OCaml or Javascript), but automatically lift the entire Rust library ecosystem into the higher level? How much of Rust could you get<!-- --> <q>for free</q> rather than reimplementing everything from scratch?</p></li><li><p>How can you teach people to design Rustic systems from first principles? Once people understand the mechanisms of Rust, how can you build on that knowledge to think architecturally?</p></li><li><p>If you understood the full dependency graph within a Rust codebase (e.g., using<!-- --> <a href="https://github.com/willcrichton/flowistry/">Flowistry</a>), how could a developer use the dependency graph as a devtool? For instance, could you automatically propose refactorings of messy code by analyzing the dependency graph?</p></li><li><p>What would a better debugger than <code>println</code> or<!-- --> <code>gdb</code> look like for Rust? How could you make use of a more powerful <abbr>UI</abbr> toolkit than the terminal?</p></li><li><p>How can we help the Rust developers make more informed design decisions about the future of the language? How should we be designing surveys or user studies or codebase analyses to test claims about prospective language features?</p></li></ol></section></details><details><summary><h4>Reactive interfaces in the browser</h4></summary><section><h5>Motivation</h5><p>Building user interfaces is hard. Human perception and cognition do not fit neatly into computer-friendly abstractions. It is a fundamental challenge in computer science to design <abbr>UI</abbr> programming models that scale, i.e., that handle complexity without brittleness. Today, the most powerful <abbr>UI</abbr> infrastructure is the browser (i.e., <abbr>HTML</abbr> + <abbr>CSS</abbr> + <abbr>JS</abbr>). The last 20 years have seen an unending parade of browser-based <abbr>UI</abbr> <!-- -->programming models: <a href="https://jquery.com/">jQuery</a>,<!-- --> <a href="https://backbonejs.org/">Backbone</a>,<!-- --> <a href="https://react.dev/">React</a>,<!-- --> <a href="https://www.solidjs.com/">Solid</a>, and<!-- --> <a href="https://svelte.dev/">Svelte</a>, just to name a few.</p><p>I started doing frontend web development in 2010 at a<!-- --> <a href="https://www.webspec.com/">web design firm</a> in my hometown of Des Moines, Iowa. I have since programmed in all of the frameworks I just listed. With that experience, I can confidently say:<!-- --> <em><abbr>UI</abbr> programming has not reached the end of history.</em> <!-- -->It is still way too difficult to express even simple interfaces. (Weirdly, <abbr>UI</abbr> programming has been largely untouched within academia for a long time. Besides<!-- --> <a href="https://www.flapjax-lang.org/">Flapjax</a> (<a href="https://dl.acm.org/doi/10.1145/1639949.1640091"><abbr>OOPSLA</abbr> 2009</a>),<!-- --> <a href="https://d3js.org/"><abbr>D3</abbr></a> <!-- -->(<a href="https://ieeexplore.ieee.org/abstract/document/6064996"><abbr>VIS</abbr> 2011</a>) and <a href="https://elm-lang.org/">Elm</a> (<a href="https://dl.acm.org/doi/abs/10.1145/2499370.2462161"><abbr>PLDI</abbr> 2013</a>), most recent progress on <abbr>UI</abbr> programming has been made within industry.)</p><p>I think <abbr>UI</abbr> programming is a fascinating topic at the intersection of <abbr>PL</abbr> and <abbr>HCI</abbr>, because it forces us to evaluate the correctness of programs in fundamentally human-centered terms. We cannot rely on the traditional <abbr>PL</abbr> <!-- -->vocabulary of type safety and undefined behavior to tell us if an interface is unusable. But I also don&#x27;t think we must throw up our hands and say<!-- --> <q>welp, humans are too complicated, <abbr>UI</abbr> programming just has to be <i>ad hoc</i>.</q></p></section><section><h5>My angle</h5><p>I have not yet published any research in this space, so I am keeping an open mind about which research ideas to pursue. But these are my preliminary angles:</p><ol><li><p><strong>How can <abbr>PL</abbr> techniques improve <abbr>UI</abbr> <!-- -->programming models?</strong> <!-- -->That is, how can we use compilation, program analysis, and type systems to design better <abbr>UI</abbr> programming models compared to just working at the library-level?<!-- --> <a href="https://elm-lang.org/">Elm</a> and<!-- --> <a href="https://svelte.dev/">Svelte</a> are good preliminary examples of this idea, but I want to go farther around ideas like dependency analysis and formal verification.</p><ul><li>I formalized the computational aspects of templating languages in<!-- --> <q><a href="#document-calculus">A Core Calculus for Documents</a></q> <!-- -->(<abbr>POPL 24</abbr>). I hope to use the language described here as the basis for future research on <abbr>UI</abbr> programming.</li></ul></li><li><p><strong>How can layout algorithms be more extensible and composable?</strong> <!-- -->Layout algorithms largely exist in silos that don&#x27;t work together and can&#x27;t be easily modified. For instance, I can&#x27;t easily compose a graph layout algorithm like<!-- --> <a href="https://graphviz.org/">Graphviz</a> with a reactive<!-- --> <abbr>UI</abbr>framework like <a href="https://react.dev/">React</a>. If I don&#x27;t like how my browser justifies text, I can&#x27;t easily reach into the internals and tweak its parameters. I am interested in systems like<!-- --> <a href="https://penrose.cs.cmu.edu/">Penrose</a> (<a href="https://dl.acm.org/doi/10.1145/3386569.3392375"><abbr>SIGGRAPH</abbr> 2020</a>) and <a href="https://bluefishjs.org/">Bluefish</a> (<a href="https://arxiv.org/abs/2307.00146">2023</a>) that provide more extensible and compositional layout primitives.</p></li></ol></section><section><h5>Project ideas</h5><ol><li><p><strong>How can a <abbr>UI</abbr> programming language generate reactive updates equivalent to hand-written code?</strong> <!-- -->The main issue addressed by newer <abbr>UI</abbr> frameworks is the<!-- --> <em>performance of reactivity.</em> That is, when the program&#x27;s state changes, how efficiently can that change propagate to the<!-- --> <abbr>UI</abbr>? React provides an execeptionally clean and expressive model for reactivity, but it comes at a cost: its<!-- --> <a href="https://legacy.reactjs.org/docs/reconciliation.html">reconciliation algorithm</a> <!-- -->can be<!-- --> <a href="https://legacy.reactjs.org/docs/optimizing-performance.html">tricky to optimize</a>. Later frameworks like Solid and Svelte limit expressiveness in exchange for performance, but they still use dynamic dependency analysis (i.e.,<!-- --> <a href="https://www.solidjs.com/tutorial/introduction_signals">signals</a> <!-- -->or <a href="https://svelte.dev/blog/runes">runes</a>) to which components depend on which state.</p><p>What if you built a <abbr>UI</abbr> language specifically around<!-- --> <em>static</em> dependency analysis? I think you could generate<!-- --> <abbr>UI</abbr>s that react more efficiently than any framework today. The key question is whether such a language would be expressive enough to permit a wide range of <abbr>UI</abbr>s.</p></li><li><p><strong>How can dynamic visual representations be formally verified?</strong> <!-- -->Say you are generating an interface, a document, or a diagram. Assume this visual object is dynamic in some way: perhaps it changes based on the reader&#x27;s screen size, or permits customization (different fonts or font sizes), or allows for interactivity. The author cannot physically look at the artifact&#x27;s appearance under all possible reading conditions. This is a perfect use case for formal verification — can we check whether the visual artifact satisfies important properties under all possible conditions?</p><p>If this interests you, ask me about my Lean prototype of a formally verified document layout engine.</p></li></ol></section></details><details><summary><h4>Proof-oriented programming with Lean and F*</h4></summary><section><h5>Motivation</h5><p>The<!-- --> <a href="https://www.fstar-lang.org/tutorial/proof-oriented-programming-in-fstar.pdf">F* tutorial</a> <!-- -->describes proof-oriented programming as:</p><blockquote>a paradigm in which one co-designs programs and proofs to provide mathematical guarantees about various aspects of a program&#x27;s behavior, including properties like functional correctness (precisely characterizing the input/output behavior of a program), security properties (e.g., ensuring that a program never leaks certain secrets), and bounds on resource usage.</blockquote><p>I think proof-oriented programming is crucial to advancing computer science as a field. Proofs provide guarantees that techniques like unit testing and fuzzing cannot, improving the reliability of software. More broadly, proofs require us to actually understand every piece of our software — a proof does not permit hand-waving.</p><p>Proof-oriented programming is just now becoming possible. Older proof assistants like <a href="https://coq.inria.fr/">Coq</a> paved the way as shown by systems like <a href="https://compcert.org/">CompCert</a> (<a href="https://xavierleroy.org/publi/compcert-CACM.pdf">2008</a>). Newer proof assistants like <a href="https://lean-lang.org/">Lean</a> <!-- -->and <a href="https://www.fstar-lang.org/">F*</a> are providing better devtools and compilation strategies, supporting ambitious research like<!-- --> <a href="https://project-everest.github.io/">Project Everest</a>.</p><p>However, these languages are extremely difficult to use. Implementing a large system would generally be considered the realm of open research, not mundane engineering. The most interesting work here is often done by people with PhDs in programming language theory. As with Rust, I do not believe these techniques will truly advance the field until they can be adopted en masse.</p><details><summary>What about Agda / Idris / Isabelle / Dafny / Liquid Haskell / etc.?</summary><p>I am emphasizing Lean and F* because I am most excited about the potential of these languages. I am more excited about languages:</p><ul><li>...with interactive theorem proving (Lean / F* / Agda / Idris / Isabelle) than automated theorem proving (Dafny / Liquid Haskell)</li><li>...with tactics (Lean / F* / Idris / Isabelle) than those without (Agda).</li><li>...that are used to implement systems (Lean / F* / Idris) rather than just prove theorems (Isabelle).</li><li>...that are commercially backed (Lean / F*) rather than independently backed (Idris).</li></ul><p>The last point is a little sad, but in practice it means the tools are more likely to get the engineering necessary to succeed.</p></details></section><section><h5>My angle</h5><ol><li><p><strong>How can we best scaffold the complexity of a proof assistant during the learning process?</strong> <!-- -->Making effective use of a proof assistant relies on a broad base of knowledge. A user should ideally know functional programming, monadic effects, the Curry-Howard correspondence, constructive logic, computability theory, abstract algebra. The proof assistant itself comes with a giant standard library consisting of thousands of theorems and dozens of tactics. I&#x27;m interested in how we can slowly ramp up users into this complexity, while still ensuring that users can accomplish useful tasks along the way.</p></li><li><p><strong>How can users have a rich conversation with the proof assistant?</strong>When authoring a proof, users need to understand the context of the proof and the actions of the assistant. The goal pane interface is one good step in this direction. But users should be able to better understand tactics (why did they succeed or failed? what was tried?), theorems (which ones could be relevant to a given goal?), and type classes (why can a given instance be found or not found?).</p></li></ol></section><section><h5>Project ideas</h5><ol><li><p>Given a proof goal, how can a tool automatically deduce the set of relevant tools and learning resources to writing the proof? How should this information be presented to the user?</p></li><li><p>What would a query language for theorems look like? What is the<!-- --> <a href="https://hoogle.haskell.org/">Hoogle</a> equivalent for Lean or F*?</p></li></ol></section></details></section><section><h3>Concepts</h3><p><em>Research interests focused on a broad vision or theory.</em></p><details><summary><h4>A cognitive theory of computational abstractions</h4></summary><section><h5>Motivation</h5><p>Programmers and <abbr>CS</abbr> researchers often claim that a language or system is <q>intuitive</q> or <q>for humans</q>. Our field rests on assumptions like<!-- --> <q>structured programming is preferable to <abbr>GOTO</abbr>s</q> <!-- -->and <q>static typing is better for large teams than dynamic typing.</q> <!-- -->And fundamentally we all believe that our choice of tools—our choice of computational abstractions—has a significant impact on our productivity and on the correctness and performance of our programs. Would you choose to program a large system in assembly instead of C? I expect not!</p><p>This state of affairs raises the question: how can we justify these beliefs? How can I argue that one set of abstractions is better than another? What are the key variables (task, programmer, environment, etc.) that affect this judgment? Programemrs will often use metrics like lines-of-code, but<!-- --> <a href="https://dl.acm.org/doi/10.1145/3426428.3426921">we need better metrics.</a> <!-- -->And while it&#x27;s important to answer these questions for our existing beliefs, the longer term goal is to help programmers<!-- --> <em>make predictions</em> about the human factors of future systems<!-- --> <em>before the system is deployed</em>. I am advocating for a predictive<!-- --> <em>cognitive theory</em> of abstraction, as opposed to iterative design methods<!-- --> <a href="https://ieeexplore.ieee.org/document/7503516">popularized in <abbr>HCI</abbr></a>.</p></section><section><h5>My angle</h5><ol><li><p><strong>How does an abstraction influence a person&#x27;s ability to decompose programming problems?</strong> <!-- -->A central task in programming is to take a problem (<q>build a website to do <i>X</i></q>,<!-- --> <q>analyze <i>Y</i> feature of a dataset</q>) and break it down into pieces that correspond to features of the language or library at hand (e.g., for loops or<!-- --> <code>List.map</code>). I think a key issue is understanding what it means to <q>think with</q> an abstraction, so one could argue why an abstraction would be better or worse for decomposition.</p><ul><li><p>An interesting domain to study is tabular data analytics, because there are dozens of meaningfully different ways to express the same concept. I wrote the<!-- --> <a href="https://willcrichton.net/expressiveness-benchmark">Expressiveness Benchmark</a> <!-- -->(2020) as a side project to experiment with different metrics for comparing the expressiveness of analytics languages and<!-- --> <abbr>API</abbr>s.</p></li></ul></li><li><p><strong>How do abstractions affect the load on cognitive resources during different programming tasks?</strong> <!-- -->People have low-level cognitive resources like <em>perception</em>,<!-- --> <em>working memory</em>, and <em>long-term memory</em> that contribute to the higher-level process of conscious thought. Abstractions can influence code&#x27;s perceptual structure (e.g., reading order or visual salience) and mnemonic structure (e.g., how many facts are needed to understand a piece of code).</p><ol><li><p><q><a href="#wm-tracing">The Role of Working Memory in Program Tracing</a></q> <!-- -->(<abbr>CHI</abbr> 2021). TODO: pick up from here</p></li></ol></li></ol></section><section><h5>Project ideas</h5><ol><li><p>TODO</p></li></ol></section></details><details><summary><h4>Visual representations of programs</h4></summary><p>TODO</p></details><details><summary><h4>Technical foundations of technical communication</h4></summary><p>TODO</p></details></section></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","_pageId":"/src/index","routeParams":{},"data":"!undefined"}</script>
        <script src="/legacy/site-redesign/assets/entries/entry-client-routing.C-2gn_Vu.js" type="module" async></script>
        <link rel="modulepreload" href="/legacy/site-redesign/assets/entries/src_index.BJsCpVV0.js" as="script" type="text/javascript">
      </body>
    </html>