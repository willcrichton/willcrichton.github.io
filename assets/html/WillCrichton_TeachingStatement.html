<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Teaching Statement</title> 
  <style></style>
  <style>
/*
 * I add this to html files generated with pandoc.
 */

 html {
  font-size: 100%;
  overflow-y: scroll;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}

body {
  color: black;
  font-family: Palatino, 'Palatino Linotype', Georgia, Times, 'Times New Roman', serif;
  font-size: 16px;
  line-height: 1.7;
  padding: 1em;
  margin: auto;
  max-width: 800px;
  background: white;
}

p {
  text-align: justify;
  hyphens: auto;
  overflow-wrap: anywhere;
}

a {
  color: #0645ad;
  text-decoration: none;
}

a:visited {
  color: #0b0080;
}

a:hover {
  color: #06e;
}

a:active {
  color: #faa700;
}

a:focus {
  outline: thin dotted;
}

p {
  margin: 1em 0;
}

img {
  max-width: 100%;
}

h1, h2, h3, h4, h5, h6 {
  color: #111;
  line-height: 125%;
  margin-top: 2em;
  font-weight: normal;
}

h4, h5, h6 {
  font-weight: bold;
}

h1 {
  font-size: 2.25em;
}

h2 {
  font-size: 1.75em;
}

h3 {
  font-size: 1.3em;
}

h4 {
  font-size: 1.1em;
}

h5 {
  font-size: 1em;
}

h6 {
  font-size: 0.9em;
}

blockquote {
  color: #666666;
  margin: 0;
  padding-left: 3em;
  border-left: 0.5em #EEE solid;
}

hr {
  display: block;
  height: 2px;
  border: 0;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #eee;
  margin: 1em 0;
  padding: 0;
}

pre, code, kbd, samp {
  color: #000;
  font-family: Inconsolata, monospace;
  /* _font-family: 'courier new', monospace; */
  font-size: 0.98em;
}

pre {
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
}

b, strong {
  font-weight: bold;
}

dfn {
  font-style: italic;
}

ins {
  background: #ff9;
  color: #000;
  text-decoration: none;
}

mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

sub, sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

ul, ol {
  margin: 1em 0;
  padding: 0 0 0 2em;
}

li p:last-child {
  margin-bottom: 0;
}

ul ul, ol ol {
  margin: .3em 0;
}

dl {
  margin-bottom: 1em;
}

dt {
  font-weight: bold;
  margin-bottom: .8em;
}

dd {
  margin: 0 0 .8em 2em;
}

dd:last-child {
  margin-bottom: 0;
}

img {
  border: 0;
  -ms-interpolation-mode: bicubic;
  vertical-align: middle;
}

figure {
  display: block;
  text-align: center;
  margin: 1em 0;
}

figure img {
  border: none;
  margin: 0 auto;
}

figcaption {
  font-size: 0.8em;
  font-style: italic;
  margin: 0 0 .8em;
}

table {
  margin-bottom: 2em;
  border-bottom: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-spacing: 0;
  border-collapse: collapse;
}

table th {
  padding: .2em 1em;
  background-color: #eee;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
}

table td {
  padding: .2em 1em;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
  vertical-align: top;
}

.author {
  font-size: 1.2em;
  text-align: center;
}

#refs {
  margin-top: 4em;
}

@media only screen and (min-width: 480px) {
  body {
    font-size: 16px;
  }
}
@media only screen and (min-width: 768px) {
  body {
    font-size: 18px;
  }
}
@media only screen and (min-width: 1200px) {
  .hero {
    width: 1200px;
    max-width: none;
    position: relative;
    right: 200px;
  }
}
@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter: none !important;
    -ms-filter: none !important;
  }

  body {
    font-size: 12pt;
    max-width: 100%;
  }

  a, a:visited {
    text-decoration: underline;
  }

  hr {
    height: 1px;
    border: 0;
    border-bottom: 1px solid black;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
    content: "";
  }

  pre, blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  tr, img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  @page :left {
    margin: 15mm 20mm 15mm 10mm;
}

  @page :right {
    margin: 15mm 10mm 15mm 20mm;
}

  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }

  h2, h3 {
    page-break-after: avoid;
  }
}

.hero {
  margin: 0.5em 0 2em;
}

h1 {
  text-align: center;
  margin-bottom: 1em;
}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Teaching Statement &nbsp; · &nbsp; Will Crichton</h1>
</header>
<p>To me, teaching is one of the great joys of academia. I love to guide
students to a deep understanding of the fundamental ideas in computer
science. This is evident in my track record: in undergrad, I was a TA
nearly every semester from sophomore to senior year, and I ran my own
mini-course for two years. Students said in TA reviews that “out of all
the TAs I had experiences with, Will stands out by far,” and “[Will’s]
skill at lecturing is something to which I aspire.” For three years of
grad school, I taught <a href="https://stanford-cs242.github.io/f19/">CS
242</a>, the graduate course on programming languages. Students said in
course reviews that CS 242 was “the most valuable computer science
course I have taken at Stanford” and “one of the best taught in the CS
department.”</p>
<p>Understanding how people learn is also an integral part of my
research on amplifying the intelligence of programmers. Programming is,
in a sense, a process of continual learning. Today’s rote tasks are
automated by tomorrow’s abstractions, and a programmer must take time to
learn those tools. In 2023, a programmer needs to learn countless
concepts: programming languages, paradigms, frameworks, libraries,
databases, devtools, and so on. Subsequently, a critical role for
intelligence amplification is to help programmers more quickly acquire
new skills. To that end, I have done research on topics like teaching
ownership types in Rust <span class="citation"
data-cites="crichton2023aquascope"><sup>[<a
href="#ref-crichton2023aquascope"
role="doc-biblioref">1</a>]</sup></span> and improving the quality of
automatically generated documentation <span class="citation"
data-cites="crichton2021docgen crichton2021scrape"><sup>[<a
href="#ref-crichton2021docgen" role="doc-biblioref">2</a>,<a
href="#ref-crichton2021scrape"
role="doc-biblioref">3</a>]</sup></span>.</p>
<h2 class="unnumbered" id="teaching-experience">Teaching Experience</h2>
<p>My formative experience was teaching five semesters as an
undergraduate teaching assistant at Carnegie Mellon. In that time, I was
a TA for <em>Functional Programming</em>, <em>Parallel and Sequential
Data Structures and Algorithms</em>, <em>Parallel Computer Architecture
and Programming</em>, and <em>Compiler Design</em>. Through recitations
I learned how to work one-on-one with students to debug their mental
models of course concepts. I also created a new mini-course, <em>Game
Development on the Web</em>. This course taught me how to construct an
informative and engaging curriculum under serious resource constraints
like one hour of lecture per week.</p>
<p>My crystallizing experience with teaching was three quarters as a
solo instructor at Stanford. In 2017, Stanford did not have a professor
available to teach CS 242: Programming Languages, so I volunteered to
take over the course. “From Theory to Systems: A Grounded Approach to
Programming Language Education” (SNAPL 2019,<span class="citation"
data-cites="crichton:LIPIcs.SNAPL.2019.4"><sup>[<a
href="#ref-crichton:LIPIcs.SNAPL.2019.4"
role="doc-biblioref">4</a>]</sup></span>) describes how I redesigned CS
242 to make PL theory more accessible to the average CS student by
placing PL concepts in real-world contexts. The use of formal semantics
was motivated with WebAssembly, the most widely-used programming
language with a complete formal semantics <span class="citation"
data-cites="haas20017wasm"><sup>[<a href="#ref-haas20017wasm"
role="doc-biblioref">5</a>]</sup></span>. The ideas in the lambda
calculus were motivated with Rust, a widely-used systems programming
language that combines functional and imperative programming. (Students
even read Wadler’s paper on linear types <span class="citation"
data-cites="wadler1990linear"><sup>[<a href="#ref-wadler1990linear"
role="doc-biblioref">6</a>]</sup></span> in one assignment!) The final
curriculum is online here: <span><a
href="https://stanford-cs242.github.io/f19/"
class="uri">https://stanford-cs242.github.io/f19/</a></span></p>
<p>In anonymous course reviews for the last iteration of Fall 2019,
students gave “How much did you learn from this course?” a mean of
4.3/5, and “How would you describe the quality of instruction in this
course?” a mean of 4.4/5. Positive comments from students included:</p>
<ul>
<li><p>“This is the best CS class I’ve taken at Stanford. You’re doing
yourself a disservice by not taking it.”</p></li>
<li><p>“I really loved this class, and it probably will be one of the
most impactful on my skills as a software engineer when I leave
Stanford.”</p></li>
<li><p>“Will is one of the best lecturers at Stanford, hands
down.”</p></li>
</ul>
<p>The course was not perfect. The experience taught me about the cost
of high velocity in curricular development. Constant reshaping of the
course meant occasional bugs and late releases of assignments. One
student wrote, “I did not like this class because though I worked very
hard [...] I still do not feel like I learned much. [...] Code was often
changed multiple times before the due date.” I take this feedback to
heart, and I will continue iteratively improving on my teaching
skills.</p>
<h2 class="unnumbered" id="teaching-philosophy">Teaching Philosophy</h2>
<p>My teaching philosophy starts with curricular design. I focus on
balancing declarative knowledge (what is a concept) and procedural
knowledge (how to use a concept). Traditional instruction often focuses
too much on declarative knowledge and rote procedural knowledge, such as
CS1 classes that teach the semantics of a for-loop, but do not teach how
to debug programs involving a for-loop. I take inspiration from texts
like <em>How to Design Programs</em> <span class="citation"
data-cites="felleisen2018design"><sup>[<a
href="#ref-felleisen2018design" role="doc-biblioref">7</a>]</sup></span>
which offer procedural knowledge as “recipes” for writing software.</p>
<p>As an example from CS 242, a traditional lesson on the lambda
calculus will include declarative knowledge about concepts like
substitution and alpha-renaming. Beyond explaining the mechanics of
substitution, I will explain the procedural knowledge of how to use
substitution in the design of a new language extension. I present a new
extensions, then show how to identify the binding structure of the
extension, and then describe both correct and incorrect ways to express
the binding structure via substitution.</p>
<p>Most learning happens outside the classroom, so I take assignment
design seriously. I create assignments that have a plausible connection
to the real world (no “foo”s and “bar”s). Each problem has an
articulable learning goal. I used to only include programming problems,
but I have since come to appreciate how written problems can surface
student misconceptions that can be glossed over with auto-grading.</p>
<p>To get a sense of how I lecture, you can watch my Strange Loop 2021
talk on “Type-Driven API Design in Rust”: <span><a
href="https://www.youtube.com/watch?v=bnnacleqg6k"
class="uri">https://www.youtube.com/watch?v=bnnacleqg6k</a></span></p>
<h2 class="unnumbered"
id="connecting-teaching-to-my-research">Connecting Teaching to My
Research</h2>
<p>Unlike most other candidates, teaching plays an essential role in my
research. I study how to make advanced programming tools more usable,
and a key factor is the tool’s learning curve. For example, Coq has been
around for 34 years, yet most people still learn Coq via a <em>de
facto</em> apprenticeship at one of the few universities with Coq
experts. The Rust roadmap’s <span class="citation"
data-cites="rust-roadmap"><sup>[<a href="#ref-rust-roadmap"
role="doc-biblioref">8</a>]</sup></span> number one priority is to
“flatten the (learning) curve.” Even for a popular language like
C++,<span class="citation" data-cites="stroustrup2020cpp"><sup>[<a
href="#ref-stroustrup2020cpp" role="doc-biblioref">9(p.
132)</a>]</sup></span> writes, “most students emerge from universities
with only weak and inaccurate understanding of C++ [...] So much could
be done to improve software if more developers using C++ knew how to use
it better!”</p>
<p>But who is positioned to address this problem? CS education
researchers and HCI researchers focus primarily on novice developers
using languages like Python and Javascript. Software engineering
researchers focus primarily on developers who already have expertise in
their language of use. Programming language researchers have written
many textbooks, but that has not been enough to overcome the learning
barrier.</p>
<p>No, what we need is researchers with deep expertise in <em>both</em>
language design and computing pedagogy who are ready to develop a
science of how to teach these languages. A science of: what does it mean
to be an effective systems programmer, or functional programmer, or
proof engineer? How do we augment the languages and their devtools to
teach the requisite skills, to ease learners into the long learning
curve? How do we translate the large body of tacit knowledge that
constitutes expertise into an explicit curriculum? I seek to address
these kinds of questions in my own research. To see a concrete example
of my vision, see the section “Teaching Ownership Types at Scale” in my
research statement.</p>
<h2 class="unnumbered" id="courses-i-can-teach">Courses I Can Teach</h2>
<p>Once I become faculty, I would be excited to teach undergraduate
courses such as: programming languages, compilers, functional
programming, parallel computing, web development, and human-computer
interaction. I can also teach graduate courses on topics such as:
performance engineering, type-safe systems programming, design and
implementation of domain-specific languages, tools for thought, and of
course my specialty: human-centered design of programming tools.</p>
<div id="refs" class="references csl-bib-body hanging-indent"
data-line-spacing="2" role="doc-bibliography">
<div id="ref-crichton2023aquascope" class="csl-entry"
role="doc-biblioentry">
1. Crichton, W., Gray, G., &amp; Krishnamurthi, S. (2023). A grounded
conceptual model for ownership types in rust. <em>Proc. ACM Program.
Lang.</em>, <em>OOPSLA2</em>.
</div>
<div id="ref-crichton2021docgen" class="csl-entry"
role="doc-biblioentry">
2. Crichton, W. (2021). Documentation generation as information
visualization. <em>Proceedings of the 11th Annual Workshop on the
Intersection of HCI and PL</em>. <a
href="http://reports-archive.adm.cs.cmu.edu/anon/isr2020/abstracts/20-115E.html">http://reports-archive.adm.cs.cmu.edu/anon/isr2020/abstracts/20-115E.html</a>
</div>
<div id="ref-crichton2021scrape" class="csl-entry"
role="doc-biblioentry">
3. Crichton, W. (2021). <em>RFC #3122: Automatically scrape code
examples for rustdoc</em>. <a
href="https://github.com/rust-lang/rfcs/blob/master/text/3123-rustdoc-scrape-examples.md">https://github.com/rust-lang/rfcs/blob/master/text/3123-rustdoc-scrape-examples.md</a>
</div>
<div id="ref-crichton:LIPIcs.SNAPL.2019.4" class="csl-entry"
role="doc-biblioentry">
4. Crichton, W. (2019). <span class="nocase">From Theory to Systems: A
Grounded Approach to Programming Language Education</span>. In B. S.
Lerner, R. Bodı́k, &amp; S. Krishnamurthi (Eds.), <em>3rd summit on
advances in programming languages (SNAPL 2019)</em> (Vol. 136, pp.
4:1–4:9). Schloss Dagstuhl – Leibniz-Zentrum f<span>ü</span>r
Informatik. <a
href="https://doi.org/10.4230/LIPIcs.SNAPL.2019.4">https://doi.org/10.4230/LIPIcs.SNAPL.2019.4</a>
</div>
<div id="ref-haas20017wasm" class="csl-entry" role="doc-biblioentry">
5. Haas, A., Rossberg, A., Schuff, D. L., Titzer, B. L., Holman, M.,
Gohman, D., Wagner, L., Zakai, A., &amp; Bastien, J. (2017). Bringing
the web up to speed with WebAssembly. <em>Proceedings of the 38th ACM
SIGPLAN Conference on Programming Language Design and
Implementation</em>, 185–200. <a
href="https://doi.org/10.1145/3062341.3062363">https://doi.org/10.1145/3062341.3062363</a>
</div>
<div id="ref-wadler1990linear" class="csl-entry" role="doc-biblioentry">
6. Wadler, P. (1990). Linear types can change the world! <em>Programming
Concepts and Methods</em>, <em>3</em>, 5.
</div>
<div id="ref-felleisen2018design" class="csl-entry"
role="doc-biblioentry">
7. Felleisen, M., Findler, R. B., Flatt, M., &amp; Krishnamurthi, S.
(2018). <em>How to design programs: An introduction to programming and
computing</em>. MIT Press.
</div>
<div id="ref-rust-roadmap" class="csl-entry" role="doc-biblioentry">
8. Triplett, J., &amp; Matsakis, N. (2022). <em>Rust lang roadmap for
2024</em>. <a
href="https://blog.rust-lang.org/inside-rust/2022/04/04/lang-roadmap-2024.html">https://blog.rust-lang.org/inside-rust/2022/04/04/lang-roadmap-2024.html</a>
</div>
<div id="ref-stroustrup2020cpp" class="csl-entry"
role="doc-biblioentry">
9. Stroustrup, B. (2020). Thriving in a crowded and changing world: C++
2006–2020. <em>Proc. ACM Program. Lang.</em>, <em>4</em>(HOPL). <a
href="https://doi.org/10.1145/3386320">https://doi.org/10.1145/3386320</a>
</div>
</div>
</body>
</html>