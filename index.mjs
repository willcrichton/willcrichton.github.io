import{a as S,b as g,c as b,d as A,e as w,f as y,g as i,h as v,i as k,j as I}from"./chunk-F7S7TLOR.mjs";var c=g(b()),f=g(A());var u={};S(u,{default:()=>d,metadata:()=>T});var e=g(b());var T={title:"Will Crichton"},d=w(n=>(0,e.createElement)(k,{...n},...(()=>[`
`,...(()=>[`
`,`
`,(0,e.createElement)("header",{},(0,e.createElement)("div",{},(0,e.createElement)("div",{},(0,e.createElement)("h1",{},"Will Crichton")),`
`,(0,e.createElement)("div",{},(0,e.createElement)("img",{className:"profile",width:200,src:"/assets/img/headshot.jpg"}))),`
`,(0,e.createElement)("div",{},(0,e.createElement)("div",{className:"links"},(0,e.createElement)("a",{className:"text",href:"mailto:wcrichto@brown.edu"},"wcrichto@brown.edu"),`
`,(0,e.createElement)("a",{className:"text",href:"/assets/pdf/WillCrichton_CV.pdf"},"CV"),`
`,(0,e.createElement)("a",{href:"https://twitter.com/tonofcrates"},(0,e.createElement)("img",{src:"/assets/img/icon-twitter.png"})),`
`,(0,e.createElement)("a",{href:"https://github.com/willcrichton/"},(0,e.createElement)("img",{src:"/assets/img/icon-github.png"}))),`
`,(0,e.createElement)("div",{},(0,e.createElement)("p",{},"I am a computer scientist that designs principled, practical systems to amplify the intelligence of programmers. My research spans programming languages (PL) and human-computer interaction (HCI) with influences from system design, cognitive psychology, and learning science."),`
`,(0,e.createElement)("p",{},"I am currently a postdoc at Brown University advised by ",(0,e.createElement)("a",{href:"https://cs.brown.edu/~sk/"},"Shriram Krishnamurthi"),", working on making ",(0,e.createElement)("a",{href:"https://rust-book.cs.brown.edu/"},"Rust easier to learn"),". I completed my Ph.D. at Stanford University advised by ",(0,e.createElement)("a",{href:"https://graphics.stanford.edu/~hanrahan/"},"Pat Hanrahan")," and ",(0,e.createElement)("a",{href:"http://graphics.stanford.edu/~maneesh/"},"Maneesh Agrawala"),".")))),`
`,`
`,...(()=>{let o="(";return[`
`,...(()=>{let r=")";return[`
`,`
`,(0,e.createElement)("section",{className:"callout-wrapper"},(0,e.createElement)("div",{className:"callout"},(0,e.createElement)("strong",{},"I am on the job market for a tenure-track research professorship.")," You can read a draft of my ",`
`,"research statement ",o,(0,e.createElement)("a",{href:"/assets/html/WillCrichton_ResearchStatement.html"},"html"),", ",(0,e.createElement)("a",{href:"/assets/pdf/WillCrichton_ResearchStatement.pdf"},"pdf"),r,",",`
`,"teaching statement ",o,(0,e.createElement)("a",{href:"/assets/html/WillCrichton_TeachingStatement.html"},"html"),", ",(0,e.createElement)("a",{href:"/assets/pdf/WillCrichton_TeachingStatement.pdf"},"pdf"),r,",",`
`,"diversity statement ",o,(0,e.createElement)("a",{href:"/assets/html/WillCrichton_DiversityStatement.html"},"html"),", ",(0,e.createElement)("a",{href:"/assets/pdf/WillCrichton_DiversityStatement.pdf"},"pdf"),r,",",`
`,"and curriculum vitae ",o,(0,e.createElement)("a",{href:"/assets/pdf/WillCrichton_CV.pdf"},"pdf"),r,".")),`
`,`
`,(0,e.createElement)("section",{className:"portfolio shaded"},...(()=>{let s=({children:l,gap:t})=>(0,e.createElement)("div",{className:`grid gap-${t||"1rem"}`},l);return[`
`,(0,e.createElement)("p",{},"In my research, I build ",(0,e.createElement)("em",{},"theories")," and ",(0,e.createElement)("em",{},"systems")," about programming. A theory examines a concept in a simplified setting where its properties can be identified via logical or statistical analysis. A system applies theory to a real-world setting where unexpected constraints and engineering concerns influence the theory's application."),`
`,(0,e.createElement)(s,{gap:"2rem"},...(()=>{let l=[["infoflow",(0,e.createElement)("p",{},"I developed an algorithm for using ownership types to statically & modularly analyze information flow, and proved its soundness as noninterference ",(0,e.createElement)(i,{},"infoflow"),".")],["memory",(0,e.createElement)("p",{},"I ran experiments that demonstrated how working memory limits a person's ability to remember the value of variables while program tracing ",(0,e.createElement)(i,{},"tracing-wm"),".")],["docgen",(0,e.createElement)("p",{},"I articulated a design space for documentation generators based on the information needs of developers ",(0,e.createElement)(i,{},"docgen-infovis"),".")],["cluster",(0,e.createElement)("p",{},"I demonstrated that machine learning models can accurately classify a program's high-level structure ",(0,e.createElement)(i,{},"structure-classification"),".")]];return[`
`,(0,e.createElement)("div",{className:"theories"},(0,e.createElement)("h2",{},"Theories"),`
`,(0,e.createElement)(s,{},l.map(([t,a],m)=>(0,e.createElement)("div",{key:m},(0,e.createElement)("img",{src:`/assets/img/theory-${t}.jpg`}),`
`,a)))),`
`,`
`,...(()=>{let t=[["flowistry",(0,e.createElement)("p",{},"I built ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/flowistry/"},"Flowistry"),", a static information flow analysis for Rust, to help programmers identify code unrelated to their current task ",(0,e.createElement)(i,{},"infoflow"),".")],["cs242",(0,e.createElement)("p",{},"I redesigned ",(0,e.createElement)("a",{href:"https://stanford-cs242.github.io/f19/"},"CS 242"),", a graduate-level course on programming languages, to help students better understand how PL theory works in the real world ",(0,e.createElement)(i,{},"plclass"),".")],["rustdoc",(0,e.createElement)("p",{},"I extended ",(0,e.createElement)("a",{href:"https://doc.rust-lang.org/rustdoc"},"Rustdoc")," to help programmers learn new APIs by ",(0,e.createElement)("a",{href:"https://twitter.com/wcrichton/status/1456112165744615426"},"automatically linking documentation to code examples"),".")],["nota",(0,e.createElement)("p",{},"I created ",(0,e.createElement)("a",{href:"https://nota-lang.org/"},"Nota"),", a document language for the browser, to make a world where I never have to write LaTeX again ",(0,e.createElement)(i,{},"nota"),".")]];return[`
`,(0,e.createElement)("div",{className:"projects"},(0,e.createElement)("h2",{},"Systems"),`
`,(0,e.createElement)(s,{},t.map(([a,m],h)=>(0,e.createElement)("div",{key:h},(0,e.createElement)("img",{src:`/assets/img/system-${a}.jpg`}),`
`,m))))]})()]})())]})()),`
`,`
`,...(()=>{let s=[{name:"rust-book-experiment",paper:"https://arxiv.org/abs/2401.01257",github:"https://github.com/cognitive-engineering-lab/rust-book",title:"Profiling Programming Language Learning",venue:"OOPSLA",authors:["Will Crichton","Shriram Krishnamurthi"],year:2024,kind:"conference",upcoming:!0},{name:"document-calculus",paper:"https://arxiv.org/abs/2310.04368",github:"https://github.com/cognitive-engineering-lab/document-calculus",title:"A Core Calculus for Documents",authors:["Will Crichton","Shriram Krishnamurthi"],venue:"POPL",year:2024,kind:"conference",upcoming:!0},{name:"design-patterns",paper:"https://arxiv.org/abs/2307.07069",title:"Typed Design Patterns for the Functional Era",authors:["Will Crichton"],venue:"FUNARCH @ ICFP",year:2023,kind:"workshop"},{name:"aquascope",paper:"https://arxiv.org/abs/2309.04134",github:"https://github.com/cognitive-engineering-lab/aquascope",title:"A Grounded Conceptual Model for Ownership Types in Rust",authors:["Will Crichton","Gavin Gray","Shriram Krishnamurthi"],venue:"OOPSLA",year:2023,kind:"conference"},{name:"infoflow",paper:"https://arxiv.org/abs/2111.13662",github:"https://github.com/willcrichton/flowistry",title:"Modular Information Flow Through Ownership",authors:["Will Crichton","Marco Patrignani","Maneesh Agrawala","Pat Hanrahan"],venue:"PLDI",year:2022,kind:"conference"},{name:"nota",paper:"https://willcrichton.net/nota/",github:"https://github.com/willcrichton/nota",title:"A New Medium for Communicating Research on Programming Languages",authors:["Will Crichton"],venue:"HATRA @ SPLASH",year:2021,kind:"workshop"},{name:"tracing-wm",title:"The Role of Working Memory in Program Tracing",paper:"https://arxiv.org/abs/2101.06305",authors:["Will Crichton","Maneesh Agrawala","Pat Hanrahan"],venue:"CHI",year:2021,kind:"conference"},{name:"structure-classification",title:"Automating Program Structure Classification",paper:"https://arxiv.org/abs/2101.10087",github:"https://github.com/willcrichton/autoplan",authors:["Will Crichton","Georiga Gabriela Sampaio","Pat Hanrahan"],venue:"SIGCSE",year:2021,kind:"conference"},{title:"Analysis of Faces in a Decade of US Cable TV News",paper:"https://jhong93.github.io/pdf/tvnews-kdd21.pdf",site:"https://tvnews.stanford.edu",authors:"James Hong, Will Crichton, Haotian Zhang, Daniel Y. Fu, Jacob Ritchie, Jeremy Barenholtz, Ben Hannel, Xinwei Yao, Michaela Murray, Geraldine Moriba, Maneesh Agrawala, Kayvon Fatahalian".split(", "),venue:"KDD",year:2021,kind:"conference"},{name:"docgen-infovis",title:"Documentation Generation as Information Visualization",paper:"https://arxiv.org/abs/2011.05600",authors:["Will Crichton"],venue:"PLATEAU @ SPLASH",year:2020,kind:"workshop"},{title:"Scanner: Efficient Video Analysis at Scale",github:"https://github.com/scanner-research/scanner",paper:"https://arxiv.org/abs/1805.07339",authors:["Fait Poms","Will Crichton","Pat Hanrahan","Kayvon Fatahalian"],venue:"SIGGRAPH",year:2019,kind:"conference"},{title:"Rekall: Specifying Video Events using Compositions of Spatiotemporal Labels",paper:"https://arxiv.org/abs/1910.02993",authors:"Daniel Y. Fu, Will Crichton, James Hong, Xinwei Yao, Haotian Zhang, Anh Truong, Avanika Narayan, Maneesh Agrawala, Christopher R\xE9, Kayvon Fatahalian".split(", "),venue:"AI Systems @ SOSP",year:2019,kind:"workshop"},{name:"plclass",title:"From Theory to Systems: A Grounded Approach to Programming Language Education",paper:"https://arxiv.org/abs/1904.06750",authors:["Will Crichton"],venue:"SNAPL",year:2019,kind:"workshop"}];return[`
`,`
`,...(()=>{let l=({pub:t,index:a})=>(0,e.createElement)(y,{block:!0,name:t.name,label:[["[",a,"]"]]},(0,e.createElement)("div",{className:"pub"},(0,e.createElement)("div",{className:"pub-title"},t.paper?(0,e.createElement)("a",{href:t.paper},t.title,"."):(0,e.createElement)("span",{style:{fontWeight:500}},t.title,".")),`
`,(0,e.createElement)("div",{},(0,e.createElement)("p",{className:"pub-authors"},...(()=>{let m="Will Crichton";return[`
`,t.authors.map((h,x)=>{let p=h==m?(0,e.createElement)("span",{key:h,className:"author-me"},h):h;return t.authors.length==1?p:x==t.authors.length-1?[[" and ",p]]:t.authors.length==2?[[p]]:[[p,", "]]}),"."]})())),`
`,(0,e.createElement)("div",{},(0,e.createElement)("p",{},t.venue?[[t.venue," ",t.year," ",t.upcoming?"(to appear)":""]]:[["Under submission"]],"."))));return[`
`,`
`,(0,e.createElement)("section",{className:"publications"},(0,e.createElement)("h2",{},"Selected Publications"),`
`,`
`,(0,e.createElement)("h3",{},"Conference publications"),`
`,`
`,s.map((t,a)=>[t,a]).filter(([t])=>t.kind=="conference").map(([t,a])=>(0,e.createElement)(l,{key:a,pub:t,index:a})),`
`,`
`,(0,e.createElement)("h3",{},"Workshop publications"),`
`,`
`,s.map((t,a)=>[t,a]).filter(([t])=>t.kind=="workshop").map(([t,a])=>(0,e.createElement)(l,{key:a,pub:t,index:a}))),`
`,`
`,`
`,(0,e.createElement)("section",{className:"ideas shaded"},(0,e.createElement)("div",{},(0,e.createElement)("h2",{id:"good-ideas-for-free"},"Good Ideas For Free"),`
`,(0,e.createElement)("p",{style:{marginTop:"1rem"}},"Here are some ideas that I worked on a bit, but haven't had time to keep exploring. If any of them are exciting to you, please reach out and I would love to chat!"),`
`,(0,e.createElement)("ol",{},(0,e.createElement)("li",{},"It should be possible to build a garbage-collected programming language on top of a non-GC language, ",(0,e.createElement)("em",{},"and get the standard library for free!"),`
`,"For instance, there should be a version of OCaml built on Rust that doesn't need to reimplement ",(0,e.createElement)("code",{},"Vec")," or ",(0,e.createElement)("code",{},"HashMap"),". See: ",(0,e.createElement)("q",{},(0,e.createElement)("a",{href:"https://willcrichton.net/notes/gradual-programming/"},"Gradual Programming")),", ",(0,e.createElement)("q",{},(0,e.createElement)("a",{href:"/notes/rust-the-new-llvm/"},"Rust: The New LLVM"))," and ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/lia"},"willcrichton/lia"),"."),`
`,(0,e.createElement)("li",{},"When a CS teacher gets 100 solutions from students to a new assignment, the teacher should have tools that help them explore the commonalities and differences between solutions. I worked on this a bit ",(0,e.createElement)(i,{},"structure-classification"),". See also ",(0,e.createElement)("a",{href:"https://web.stanford.edu/~cpiech/bio/papers/generativeGrading.pdf"},'"Generative Grading: Neural Approximate Parsing for Automated Student Feedback"')," for another cool concept in this space."),`
`,(0,e.createElement)("li",{},"Trait-based languages like Rust have a ",(0,e.createElement)("a",{href:"https://sdleffler.github.io/RustTypeSystemTuringComplete/"},"Turing-complete")," logic-programming-esque computation model embedded into their type system. I built ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/tyrade"},"Tyrade")," to show that it's possible to translate a sensible functional language into traits. But the translation is limited and I never formally proved the kind of relationship between these languages."),`
`,(0,e.createElement)("li",{},"Probabilistic programming languages offer an unprecedented new capability to model problems involving uncertainty. But most PPL texts focus on teaching the mechanics of the language rather than how to map a domain task into a probabilistic program. Can we systematically describe a translation from uncertain tasks to probabilistic programs? See: ",(0,e.createElement)("a",{href:"https://willcrichton.net/notes/compiling-knowledge-probability/"},"Compiling Knowledge into Probabilistic Programs"),"."),`
`,(0,e.createElement)("li",{},"Programmers often intuit that a particular API has a more direct mapping to a domain than another API, such as how many Python libraries are marketed as ",(0,e.createElement)("q",{},(0,e.createElement)("a",{href:"https://requests.readthedocs.io/en/latest/"},"for humans")),". How can we quantify the concept of ",(0,e.createElement)("q",{},"direct mapping"),"? For example, I created the ",(0,e.createElement)("a",{href:"https://willcrichton.net/expressiveness-benchmark/"},"Expressiveness Benchmark")," as a first pass on this question for tabular data processing APIs. Here's a ",(0,e.createElement)("em",{},"really")," cool idea: imagine if you (1) embedded a bunch of APIs into a theorem prover, (2) implemented the same task in each API, and (3) wrote a proof of correctness for each implementation. Does the smallest proof corresponds to the most direct mapping?"),`
`,(0,e.createElement)("li",{},"Intro to discrete math and intro to probability courses share the same problem: students get caught up in the syntax, and then fail to understand the underlying concepts. (Example: what is the type of the ",(0,e.createElement)(v,{},"P")," operator in probability?) Is it possible to improve students' learning experience with the introduction of a theorem prover or probabilistic programming language, respectively? For example, see ",(0,e.createElement)("a",{href:"https://leanprover.github.io/logic_and_proof/"},"Logic and Proof"),", a logic textbook written using ",(0,e.createElement)("a",{href:"https://leanprover.github.io/"},"Lean"),", and the ",(0,e.createElement)("a",{href:"https://www.media.mit.edu/projects/letschance/people/"},"Let's Chance")," project from MIT Media Lab."),`
`,(0,e.createElement)("li",{},"When programmers have questions about an API, they only use documentation and StackOverflow, rarely looking at the source code. That's not unreasonable: production-grade libraries have multiple layers of abstraction that make it hard to explore code. What if we equipped programmers with spelunking tools that could break through these abstractions? For example, I worked on ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/inliner"},"Inliner"),", a tool that uses source-to-source compiler optimizations to show how a library works in the context of an example. See also: ",(0,e.createElement)("a",{href:"https://ieeexplore.ieee.org/abstract/document/263907"},(0,e.createElement)("q",{},"Partial evaluation as an aid to the comprehension of Fortran programs"))," and ",(0,e.createElement)("a",{href:"https://ieeexplore.ieee.org/abstract/document/601266"},(0,e.createElement)("q",{},"Amorphous program slicing")),"."),`
`,(0,e.createElement)("li",{},"Scientists learning to program in R have to deal with the language's god-awful ergonomics and error messages. How can tooling provide contextual assistance to help learners better understand how the langauge works? I built a prototype ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/r-autota"},"Auto TA")," for RStudio which learners seemed to really enjoy."),`
`,(0,e.createElement)("li",{},"System designers have a vocabulary of common system components that recur across domains: state machines, event registries, access control, so on. I've always thought that ",(0,e.createElement)("q",{},"design patterns")," should be articulated in terms of these kinds of components, not stuff like a ",(0,e.createElement)("q",{},"visitor"),". For example, I wrote a mini-book ",(0,e.createElement)("a",{href:"https://willcrichton.net/rust-api-type-patterns/"},"Type-Driven API Design in Rust")," that shows how to idiomatically express system components in Rust, and what mistakes you can catch at compile-time with careful design. But I think a more systematic enumeration of these kinds of system idioms would be really interesting. See also: ",(0,e.createElement)("a",{href:"https://en.wikipedia.org/wiki/Domain-driven_design"},"domain-driven design"),"."),`
`,(0,e.createElement)("li",{},"For sufficiently well-defined and low-level programming tasks, it should be possible to build a probabilistic cognitive model that could accurately predict a person's behavior in solving the task. For example, after publishing ",(0,e.createElement)("q",{},"The Role of Working Memory in Program Tracing")," ",(0,e.createElement)(i,{},"tracing-wm"),", I explored the idea of modeling a person as a ",(0,e.createElement)("q",{},"lossy")," interpreter, and whether you could tune the lossiness parameters to explain the range of observed human traces. The models actually worked, although I never figured out what a useful application of such a cognitive model would be. Maybe you can!"))))]})()]})()]})()]})()])()])()));var P="metadata",W=P in u?u[P]:{},L=n=>c.default.createElement(I,{...n},c.default.createElement("div",{id:"root"},c.default.createElement(d,null))),C=async n=>{let o=Date.now(),r=new MutationObserver(s=>{o=Date.now()});return r.observe(n,{subtree:!0,childList:!0,attributes:!0}),new Promise(s=>{let l=setInterval(()=>{Date.now()-o>1e3&&(clearInterval(l),r.disconnect(),s())},50)})},N=async()=>{let n=document.documentElement;if(n.classList.contains("ssr-env"))n.classList.remove("ssr-env"),f.default.render(c.default.createElement(L,{...W,script:"./index.mjs"}),n),await C(n),window.NOTA_READY=!0;else{let o=document.getElementById("root"),r=document.createElement("div");f.default.render(c.default.createElement(d,null),r),await C(r),o.parentNode.replaceChild(r,o)}};N();
