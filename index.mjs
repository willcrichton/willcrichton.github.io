import{a as P,b as d,c as g,d as x,e as f,f as w,g as i,h as b,i as y,j as v}from"./chunk-EW2ISSMV.mjs";var l=d(g()),u=d(x());var p={};P(p,{default:()=>c,metadata:()=>S});var e=d(g());var S={title:"Will Crichton"},c=f(n=>(0,e.createElement)(y,{...n},...(()=>[`
`,...(()=>[`
`,`
`,(0,e.createElement)("header",{},(0,e.createElement)("div",{},(0,e.createElement)("div",{},(0,e.createElement)("h1",{},"Will Crichton")),`
`,(0,e.createElement)("div",{},(0,e.createElement)("img",{className:"profile",width:200,src:"/assets/img/headshot.jpg"}))),`
`,(0,e.createElement)("div",{},(0,e.createElement)("div",{className:"links"},(0,e.createElement)("a",{className:"text",href:"mailto:wcrichto@cs.stanford.edu"},"wcrichto@brown.edu"),`
`,(0,e.createElement)("a",{className:"text",href:"/assets/pdf/WillCrichton_CV.pdf"},"CV"),`
`,(0,e.createElement)("a",{href:"https://twitter.com/wcrichton"},(0,e.createElement)("img",{src:"/assets/img/icon-twitter.png"})),`
`,(0,e.createElement)("a",{href:"https://github.com/willcrichton/"},(0,e.createElement)("img",{src:"/assets/img/icon-github.png"}))),`
`,(0,e.createElement)("div",{},(0,e.createElement)("p",{},"I am a computer scientist. My research combines cognitive psychology and programming language theory to understand how people program, and to design better tools for programmers."),`
`,(0,e.createElement)("p",{},"I am currently a postdoc at Brown University advised by ",(0,e.createElement)("a",{href:"https://cs.brown.edu/~sk/"},"Shriram Krishnamurthi"),", working on making ",(0,e.createElement)("a",{href:"https://www.rust-lang.org/"},"Rust")," easier to learn. I completed my Ph.D. at Stanford University advised by ",(0,e.createElement)("a",{href:"https://graphics.stanford.edu/~hanrahan/"},"Pat Hanrahan")," and ",(0,e.createElement)("a",{href:"http://graphics.stanford.edu/~maneesh/"},"Maneesh Agrawala"),". I will be on the academic job market in the 2023-24 cycle.")))),`
`,`
`,(0,e.createElement)("section",{className:"portfolio shaded"},...(()=>{let r=({children:o,gap:t})=>(0,e.createElement)("div",{className:`grid gap-${t||"1rem"}`},o);return[`
`,(0,e.createElement)("p",{},"In my research I build ",(0,e.createElement)("em",{},"theories")," and ",(0,e.createElement)("em",{},"systems")," about programming. A theory tries to understand a concept in a simplified setting where its properties can be identified via logical or statistical analysis. A system applies theory to a real-world setting where unexpected constraints and engineering concerns influence the theory's application."),`
`,(0,e.createElement)(r,{gap:"2rem"},...(()=>{let o=[["infoflow",(0,e.createElement)("p",{},"I developed an algorithm for using ownership types to statically / modularly analyze information flow, and proved its soundness as noninterference ",(0,e.createElement)(i,{},"infoflow"),".")],["memory",(0,e.createElement)("p",{},"I showed that working memory limits a person's ability to remember the value of variables while program tracing ",(0,e.createElement)(i,{},"tracing-wm"),".")],["docgen",(0,e.createElement)("p",{},"I articulated a design space for documentation generators based on a cognitive task analysis of how developers search through APIs ",(0,e.createElement)(i,{},"docgen-infovis"),".")],["cluster",(0,e.createElement)("p",{},"I demonstrated that machine learning models can classify a program's high-level structure to a high degree of accuracy ",(0,e.createElement)(i,{},"structure-classification"),".")]];return[`
`,(0,e.createElement)("div",{className:"theories"},(0,e.createElement)("h2",{},"Theories"),`
`,(0,e.createElement)(r,{},o.map(([t,a],h)=>(0,e.createElement)("div",{key:h},(0,e.createElement)("img",{src:`/assets/img/theory-${t}.jpg`}),`
`,a)))),`
`,`
`,...(()=>{let t=[["flowistry",(0,e.createElement)("p",{},"I built ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/flowistry/"},"Flowistry"),", an information flow analyzer for Rust, to help programmers identify code unrelated to their current task ",(0,e.createElement)(i,{},"infoflow"),".")],["cs242",(0,e.createElement)("p",{},"I redesigned ",(0,e.createElement)("a",{href:"https://stanford-cs242.github.io/f19/"},"CS 242"),", a graduate-level course on programming languages, to help students better understand how PL theory works in the real world ",(0,e.createElement)(i,{},"plclass"),".")],["rustdoc",(0,e.createElement)("p",{},"I extended ",(0,e.createElement)("a",{href:"https://doc.rust-lang.org/rustdoc"},"Rustdoc")," to ",(0,e.createElement)("a",{href:"https://twitter.com/wcrichton/status/1456112165744615426"},"automatically find examples")," for documented functions, to help programmers find examples when learning a new API.")],["nota",(0,e.createElement)("p",{},"I created ",(0,e.createElement)("a",{href:"https://nota-lang.org/"},"Nota"),", a document language for the browser, to make a world where I never have to write LaTeX again ",(0,e.createElement)(i,{},"nota"),".")]];return[`
`,(0,e.createElement)("div",{className:"projects"},(0,e.createElement)("h2",{},"Systems"),`
`,(0,e.createElement)(r,{},t.map(([a,h],s)=>(0,e.createElement)("div",{key:s},(0,e.createElement)("img",{src:`/assets/img/system-${a}.jpg`}),`
`,h))))]})()]})())]})()),`
`,`
`,`
`,`
`,`
`,...(()=>{let r=[{name:"infoflow-apps",paper:"TODO",title:"Applying Information Flow to Program Comprehension",authors:["Will Crichton"],kind:"workshop",venue:"PLATEAU",year:2021},{name:"infoflow",paper:"https://arxiv.org/abs/2111.13662",github:"https://github.com/willcrichton/flowistry",title:"Modular Information Flow Through Ownership",authors:["Will Crichton","Marco Patrignani","Maneesh Agrawala","Pat Hanrahan"],venue:"PLDI",year:2022,kind:"conference"},{name:"nota",paper:"https://willcrichton.net/nota/",github:"https://github.com/willcrichton/nota",title:"A New Medium for Communicating Research on Programming Languages",authors:["Will Crichton"],venue:"HATRA @ SPLASH",year:2021,kind:"workshop"},{name:"tracing-wm",title:"The Role of Working Memory in Program Tracing",paper:"https://arxiv.org/abs/2101.06305",authors:["Will Crichton","Maneesh Agrawala","Pat Hanrahan"],venue:"CHI",year:2021,kind:"conference"},{name:"structure-classification",title:"Automating Program Structure Classification",paper:"https://arxiv.org/abs/2101.10087",github:"https://github.com/willcrichton/autoplan",authors:["Will Crichton","Georiga Gabriela Sampaio","Pat Hanrahan"],venue:"SIGCSE",year:2021,kind:"conference"},{title:"Analysis of Faces in a Decade of US Cable TV News",paper:"https://jhong93.github.io/pdf/tvnews.pdf",site:"https://tvnews.stanford.edu",authors:"James Hong, Will Crichton, Haotian Zhang, Daniel Y. Fu, Jacob Ritchie, Jeremy Barenholtz, Ben Hannel, Xinwei Yao, Michaela Murray, Geraldine Moriba, Maneesh Agrawala, Kayvon Fatahalian".split(", "),venue:"KDD",year:2021,kind:"conference"},{name:"docgen-infovis",title:"Documentation Generation as Information Visualization",paper:"https://arxiv.org/abs/2011.05600",authors:["Will Crichton"],venue:"PLATEAU @ SPLASH",year:2020,kind:"workshop"},{title:"The Usability of Ownership",paper:"https://arxiv.org/abs/2011.06171",authors:["Will Crichton"],venue:"HATRA @ SPLASH",year:2020,kind:"workshop"},{title:"Human-Centric Program Synthesis",paper:"https://arxiv.org/abs/1909.12281",authors:["Will Crichton"],venue:"PLATEAU @ UIST",year:2019,kind:"workshop"},{title:"Scanner: Efficient Video Analysis at Scale",github:"https://github.com/scanner-research/scanner",paper:"https://arxiv.org/abs/1805.07339",authors:["Fait Poms","Will Crichton","Pat Hanrahan","Kayvon Fatahalian"],venue:"SIGGRAPH",year:2019,kind:"conference"},{title:"Rekall: Specifying Video Events using Compositions of Spatiotemporal Labels",paper:"https://arxiv.org/abs/1910.02993",authors:"Daniel Y. Fu, Will Crichton, James Hong, Xinwei Yao, Haotian Zhang, Anh Truong, Avanika Narayan, Maneesh Agrawala, Christopher R\xE9, Kayvon Fatahalian".split(", "),venue:"AI Systems @ SOSP",year:2019,kind:"workshop"},{name:"plclass",title:"From Theory to Systems: A Grounded Approach to Programming Language Education",paper:"https://arxiv.org/abs/1904.06750",authors:["Will Crichton"],venue:"SNAPL",year:2019,kind:"workshop"},{title:"Identifying Barriers to Adoption for Rust through Online Discourse",paper:"https://arxiv.org/abs/1901.01001",authors:["Anna Zeng","Will Crichton"],venue:"PLATEAU @ SPLASH",year:2018,kind:"workshop"}];return[`
`,`
`,...(()=>{let o=({pub:t,index:a})=>(0,e.createElement)(w,{block:!0,name:t.name,label:[["[",a,"]"]]},(0,e.createElement)("div",{className:"pub"},(0,e.createElement)("div",{className:"pub-title"},(0,e.createElement)("a",{href:t.paper},t.title,".")),`
`,(0,e.createElement)("div",{},(0,e.createElement)("p",{className:"pub-authors"},...(()=>{let h="Will Crichton";return[`
`,t.authors.map((s,A)=>{let m=s==h?(0,e.createElement)("span",{key:s,className:"author-me"},s):s;return t.authors.length==1?m:A==t.authors.length-1?[[" and ",m]]:[[m,", "]]}),"."]})())),`
`,(0,e.createElement)("div",{},(0,e.createElement)("p",{},t.venue?[[t.venue," ",t.year]]:[["Under submission"]],"."))));return[`
`,`
`,(0,e.createElement)("section",{className:"publications"},(0,e.createElement)("h2",{},"Publications"),`
`,`
`,(0,e.createElement)("h3",{},"Conference publications"),`
`,`
`,r.map((t,a)=>[t,a]).filter(([t])=>t.kind=="conference").map(([t,a])=>(0,e.createElement)(o,{key:a,pub:t,index:a})),`
`,`
`,(0,e.createElement)("h3",{},"Workshop publications"),`
`,(0,e.createElement)("p",{style:{marginBottom:"1rem",fontStyle:"italic"}},"I love workshops! I enjoy discussing my half-baked or weirdly-niche ideas with other researchers. ",(0,e.createElement)("a",{href:"https://plateau-workshop.org/"},"PLATEAU")," and ",(0,e.createElement)("a",{href:"https://snapl.org/"},"SNAPL")," were a big part of the reason I got into PL/HCI research."),`
`,`
`,r.map((t,a)=>[t,a]).filter(([t])=>t.kind=="workshop").map(([t,a])=>(0,e.createElement)(o,{key:a,pub:t,index:a}))),`
`,`
`,`
`,(0,e.createElement)("section",{className:"ideas shaded"},(0,e.createElement)("div",{},(0,e.createElement)("h2",{},"Good Ideas For Free"),`
`,(0,e.createElement)("p",{style:{marginTop:"1rem"}},"Here are some ideas that I worked on a bit, but haven't had time to keep exploring. If any of them are exciting to you, please reach out and I would love to chat!"),`
`,(0,e.createElement)("ol",{},(0,e.createElement)("li",{},"It should be possible to build a garbage-collected programming language on top of a non-GC language, ",(0,e.createElement)("em",{},"and get the standard library for free!"),`
`,"For instance, there should be a version of OCaml built on Rust that doesn't need to reimplement ",(0,e.createElement)("code",{},"Vec")," or ",(0,e.createElement)("code",{},"HashMap"),". See: ",(0,e.createElement)("q",{},(0,e.createElement)("a",{href:"https://willcrichton.net/notes/gradual-programming/"},"Gradual Programming")),", ",(0,e.createElement)("q",{},(0,e.createElement)("a",{href:"/notes/rust-the-new-llvm/"},"Rust: The New LLVM"))," and ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/lia"},"willcrichton/lia"),"."),`
`,(0,e.createElement)("li",{},"When a CS teacher gets 100 solutions from students to a new assignment, the teacher should have tools that help them explore the commonalities and differences between solutions. I worked on this a bit ",(0,e.createElement)(i,{},"structure-classification"),". See also ",(0,e.createElement)("a",{href:"https://web.stanford.edu/~cpiech/bio/papers/generativeGrading.pdf"},'"Generative Grading: Neural Approximate Parsing for Automated Student Feedback"')," for another cool concept in this space."),`
`,(0,e.createElement)("li",{},"Trait-based languages like Rust have a ",(0,e.createElement)("a",{href:"https://sdleffler.github.io/RustTypeSystemTuringComplete/"},"Turing-complete")," logic-programming-esque computation model embedded into their type system. I built ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/tyrade"},"Tyrade")," to show that it's possible to translate a sensible functional language into traits. But the translation is limited and I never formally proved the kind of relationship between these languages."),`
`,(0,e.createElement)("li",{},"Probabilistic programming languages offer an unprecedented new capability to model problems involving uncertainty. But most PPL texts focus on teaching the mechanics of the language rather than how to map a domain task into a probabilistic program. Can we systematically describe a translation from uncertain tasks to probabilistic programs? See: ",(0,e.createElement)("a",{href:"https://willcrichton.net/notes/compiling-knowledge-probability/"},"Compiling Knowledge into Probabilistic Programs"),"."),`
`,(0,e.createElement)("li",{},"Programmers often intuit that a particular API has a more direct mapping to a domain than another API, such as how many Python libraries are marketed as ",(0,e.createElement)("q",{},(0,e.createElement)("a",{href:"https://requests.readthedocs.io/en/latest/"},"for humans")),". How can we quantify the concept of ",(0,e.createElement)("q",{},"direct mapping"),"? For example, I created the ",(0,e.createElement)("a",{href:"https://willcrichton.net/expressiveness-benchmark/"},"Expressiveness Benchmark")," as a first pass on this question for tabular data processing APIs. Here's a ",(0,e.createElement)("em",{},"really")," cool idea: imagine if you (1) embedded a bunch of APIs into a theorem prover, (2) implemented the same task in each API, and (3) wrote a proof of correctness for each implementation. Does the smallest proof corresponds to the most direct mapping?"),`
`,(0,e.createElement)("li",{},"Intro to discrete math and intro to probability courses share the same problem: students get caught up in the syntax, and then fail to understand the underlying concepts. (Example: what is the type of the ",(0,e.createElement)(b,{},"P")," operator in probability?) Is it possible to improve students' learning experience with the introduction of a theorem prover or probabilistic programming language, respectively? For example, see ",(0,e.createElement)("a",{href:"https://leanprover.github.io/logic_and_proof/"},"Logic and Proof"),", a logic textbook written using ",(0,e.createElement)("a",{href:"https://leanprover.github.io/"},"Lean"),", and the ",(0,e.createElement)("a",{href:"https://www.media.mit.edu/projects/letschance/people/"},"Let's Chance")," project from MIT Media Lab."),`
`,(0,e.createElement)("li",{},"When programmers have questions about an API, they only use documentation and StackOverflow, rarely looking at the source code. That's not unreasonable: production-grade libraries have multiple layers of abstraction that make it hard to explore code. What if we equipped programmers with spelunking tools that could break through these abstractions? For example, I worked on ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/inliner"},"Inliner"),", a tool that uses source-to-source compiler optimizations to show how a library works in the context of an example. See also: ",(0,e.createElement)("a",{href:"https://ieeexplore.ieee.org/abstract/document/263907"},(0,e.createElement)("q",{},"Partial evaluation as an aid to the comprehension of Fortran programs"))," and ",(0,e.createElement)("a",{href:"https://ieeexplore.ieee.org/abstract/document/601266"},(0,e.createElement)("q",{},"Amorphous program slicing")),"."),`
`,(0,e.createElement)("li",{},"Scientists learning to program in R have to deal with the language's god-awful ergonomics and error messages. How can tooling provide contextual assistance to help learners better understand how the langauge works? I built a prototype ",(0,e.createElement)("a",{href:"https://github.com/willcrichton/r-autota"},"Auto TA")," for RStudio which learners seemed to really enjoy."),`
`,(0,e.createElement)("li",{},"System designers have a vocabulary of common system components that recur across domains: state machines, event registries, access control, so on. I've always thought that ",(0,e.createElement)("q",{},"design patterns")," should be articulated in terms of these kinds of components, not stuff like a ",(0,e.createElement)("q",{},"visitor"),". For example, I wrote a mini-book ",(0,e.createElement)("a",{href:"https://willcrichton.net/rust-api-type-patterns/"},"Type-Driven API Design in Rust")," that shows how to idiomatically express system components in Rust, and what mistakes you can catch at compile-time with careful design. But I think a more systematic enumeration of these kinds of system idioms would be really interesting. See also: ",(0,e.createElement)("a",{href:"https://en.wikipedia.org/wiki/Domain-driven_design"},"domain-driven design"),"."),`
`,(0,e.createElement)("li",{},"For sufficiently well-defined and low-level programming tasks, it should be possible to build a probabilistic cognitive model that could accurately predict a person's behavior in solving the task. For example, after publishing ",(0,e.createElement)("q",{},"The Role of Working Memory in Program Tracing")," ",(0,e.createElement)(i,{},"tracing-wm"),", I explored the idea of modeling a person as a ",(0,e.createElement)("q",{},"lossy")," interpreter, and whether you could tune the lossiness parameters to explain the range of observed human traces. The models actually worked, although I never figured out what a useful application of such a cognitive model would be. Maybe you can!"))))]})()]})()])()])()));var k="metadata",C=k in p?p[k]:{},T=n=>l.default.createElement(v,{...n},l.default.createElement("div",{id:"root"},l.default.createElement(c,null))),I=async n=>{let r=Date.now(),o=new MutationObserver(t=>{r=Date.now()});return o.observe(n,{subtree:!0,childList:!0,attributes:!0}),new Promise(t=>{let a=setInterval(()=>{Date.now()-r>1e3&&(clearInterval(a),o.disconnect(),t())},50)})},L=async()=>{let n=document.documentElement;if(n.classList.contains("ssr-env"))n.classList.remove("ssr-env"),u.default.render(l.default.createElement(T,{...C,script:"./index.mjs"}),n),await I(n),window.NOTA_READY=!0;else{let r=document.getElementById("root"),o=document.createElement("div");u.default.render(l.default.createElement(c,null),o),await I(o),r.parentNode.replaceChild(o,r)}};L();
