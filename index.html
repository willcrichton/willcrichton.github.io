<!DOCTYPE html><html lang="en" class=""><head><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link href="https://fonts.googleapis.com/css2?family=Cabin:ital,wght@0,400;0,700;1,400&amp;family=Expletus+Sans:wght@400;700&amp;display=swap" rel="stylesheet"><link href="index.css" rel="stylesheet"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Will Crichton</title></head><body><div id="root"><div class="nota-document"><div class="nota-document-inner"><header><div><div><h1>Will Crichton</h1></div>
<div><img class="profile" width="200" src="/assets/img/headshot.jpg"></div></div>
<div><div class="links"><a class="text" href="mailto:wcrichto@brown.edu">wcrichto@brown.edu</a>
<a class="text" href="/assets/pdf/WillCrichton_CV.pdf">CV</a>
<a href="https://twitter.com/tonofcrates"><img src="/assets/img/icon-twitter.png"></a>
<a href="https://github.com/willcrichton/"><img src="/assets/img/icon-github.png"></a></div>
<div><p>I am a computer scientist that designs principled, practical systems to amplify the intelligence of programmers. My research spans programming languages (PL) and human-computer interaction (HCI) with influences from system design, cognitive psychology, and learning science.</p>
<p>I am currently a postdoc at Brown University advised by <a href="https://cs.brown.edu/~sk/">Shriram Krishnamurthi</a>, working on making <a href="https://rust-book.cs.brown.edu/">Rust easier to learn</a>. I completed my Ph.D. at Stanford University advised by <a href="https://graphics.stanford.edu/~hanrahan/">Pat Hanrahan</a> and <a href="http://graphics.stanford.edu/~maneesh/">Maneesh Agrawala</a>.</p></div></div></header><section class="callout-wrapper"><div class="callout"><strong>I am on the job market for a tenure-track research professorship.</strong> You can read a draft of my 
research statement (<a href="/assets/html/WillCrichton_ResearchStatement.html">html</a>, <a href="/assets/pdf/WillCrichton_ResearchStatement.pdf">pdf</a>),
teaching statement (<a href="/assets/html/WillCrichton_TeachingStatement.html">html</a>, <a href="/assets/pdf/WillCrichton_TeachingStatement.pdf">pdf</a>),
diversity statement (<a href="/assets/html/WillCrichton_DiversityStatement.html">html</a>, <a href="/assets/pdf/WillCrichton_DiversityStatement.pdf">pdf</a>),
and curriculum vitae (<a href="/assets/pdf/WillCrichton_CV.pdf">pdf</a>).</div></section><section class="portfolio shaded">
<p>In my research, I build <em>theories</em> and <em>systems</em> about programming. A theory examines a concept in a simplified setting where its properties can be identified via logical or statistical analysis. A system applies theory to a real-world setting where unexpected constraints and engineering concerns influence the theory's application.</p>
<div class="grid gap-2rem">
<div class="theories"><h2>Theories</h2>
<div class="grid gap-1rem"><div><img src="/assets/img/theory-infoflow.jpg">
<p>I developed an algorithm for using ownership types to statically &amp; modularly analyze information flow, and proved its soundness as noninterference <a href="#def-infoflow" class="ref">[3]</a>.</p></div><div><img src="/assets/img/theory-memory.jpg">
<p>I ran experiments that demonstrated how working memory limits a person's ability to remember the value of variables while program tracing <a href="#def-tracing-wm" class="ref">[5]</a>.</p></div><div><img src="/assets/img/theory-docgen.jpg">
<p>I articulated a design space for documentation generators based on the information needs of developers <a href="#def-docgen-infovis" class="ref">[8]</a>.</p></div><div><img src="/assets/img/theory-cluster.jpg">
<p>I demonstrated that machine learning models can accurately classify a program's high-level structure <a href="#def-structure-classification" class="ref">[6]</a>.</p></div></div></div>


<div class="projects"><h2>Systems</h2>
<div class="grid gap-1rem"><div><img src="/assets/img/system-flowistry.jpg">
<p>I built <a href="https://github.com/willcrichton/flowistry/">Flowistry</a>, a static information flow analysis for Rust, to help programmers identify code unrelated to their current task <a href="#def-infoflow" class="ref">[3]</a>.</p></div><div><img src="/assets/img/system-cs242.jpg">
<p>I redesigned <a href="https://stanford-cs242.github.io/f19/">CS 242</a>, a graduate-level course on programming languages, to help students better understand how PL theory works in the real world <a href="#def-plclass" class="ref">[11]</a>.</p></div><div><img src="/assets/img/system-rustdoc.jpg">
<p>I extended <a href="https://doc.rust-lang.org/rustdoc">Rustdoc</a> to help programmers learn new APIs by <a href="https://twitter.com/wcrichton/status/1456112165744615426">automatically linking documentation to code examples</a>.</p></div><div><img src="/assets/img/system-nota.jpg">
<p>I created <a href="https://nota-lang.org/">Nota</a>, a document language for the browser, to make a world where I never have to write LaTeX again <a href="#def-nota" class="ref">[4]</a>.</p></div></div></div></div></section><section class="publications"><h2>Selected Publications</h2>

<h3>Conference publications</h3>

<div id="def-document-calculus" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/2310.04368">A Core Calculus for Documents.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>,  and Shriram Krishnamurthi.</p></div>
<div><p>POPL 2024 (to appear).</p></div></div></div><div id="def-aquascope" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/2309.04134">A Grounded Conceptual Model for Ownership Types in Rust.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>, Gavin Gray,  and Shriram Krishnamurthi.</p></div>
<div><p>OOPSLA 2023 .</p></div></div></div><div id="def-infoflow" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/2111.13662">Modular Information Flow Through Ownership.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>, Marco Patrignani, Maneesh Agrawala,  and Pat Hanrahan.</p></div>
<div><p>PLDI 2022 .</p></div></div></div><div id="def-tracing-wm" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/2101.06305">The Role of Working Memory in Program Tracing.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>, Maneesh Agrawala,  and Pat Hanrahan.</p></div>
<div><p>CHI 2021 .</p></div></div></div><div id="def-structure-classification" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/2101.10087">Automating Program Structure Classification.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>, Georiga Gabriela Sampaio,  and Pat Hanrahan.</p></div>
<div><p>SIGCSE 2021 .</p></div></div></div><div id="def-1" class="definition"><div class="pub"><div class="pub-title"><a href="https://jhong93.github.io/pdf/tvnews-kdd21.pdf">Analysis of Faces in a Decade of US Cable TV News.</a></div>
<div><p class="pub-authors">
James Hong, <span class="author-me">Will Crichton</span>, Haotian Zhang, Daniel Y. Fu, Jacob Ritchie, Jeremy Barenholtz, Ben Hannel, Xinwei Yao, Michaela Murray, Geraldine Moriba, Maneesh Agrawala,  and Kayvon Fatahalian.</p></div>
<div><p>KDD 2021 .</p></div></div></div><div id="def-2" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/1805.07339">Scanner: Efficient Video Analysis at Scale.</a></div>
<div><p class="pub-authors">
Fait Poms, <span class="author-me">Will Crichton</span>, Pat Hanrahan,  and Kayvon Fatahalian.</p></div>
<div><p>SIGGRAPH 2019 .</p></div></div></div>

<h3>Workshop publications</h3>

<div id="def-design-patterns" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/2307.07069">Typed Design Patterns for the Functional Era.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>.</p></div>
<div><p>FUNARCH @ ICFP 2023 .</p></div></div></div><div id="def-nota" class="definition"><div class="pub"><div class="pub-title"><a href="https://willcrichton.net/nota/">A New Medium for Communicating Research on Programming Languages.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>.</p></div>
<div><p>HATRA @ SPLASH 2021 .</p></div></div></div><div id="def-docgen-infovis" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/2011.05600">Documentation Generation as Information Visualization.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>.</p></div>
<div><p>PLATEAU @ SPLASH 2020 .</p></div></div></div><div id="def-3" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/1910.02993">Rekall: Specifying Video Events using Compositions of Spatiotemporal Labels.</a></div>
<div><p class="pub-authors">
Daniel Y. Fu, <span class="author-me">Will Crichton</span>, James Hong, Xinwei Yao, Haotian Zhang, Anh Truong, Avanika Narayan, Maneesh Agrawala, Christopher RÃ©,  and Kayvon Fatahalian.</p></div>
<div><p>AI Systems @ SOSP 2019 .</p></div></div></div><div id="def-plclass" class="definition"><div class="pub"><div class="pub-title"><a href="https://arxiv.org/abs/1904.06750">From Theory to Systems: A Grounded Approach to Programming Language Education.</a></div>
<div><p class="pub-authors">
<span class="author-me">Will Crichton</span>.</p></div>
<div><p>SNAPL 2019 .</p></div></div></div></section><section class="ideas shaded"><div><h2 id="good-ideas-for-free">Good Ideas For Free</h2>
<p style="margin-top: 1rem;">Here are some ideas that I worked on a bit, but haven't had time to keep exploring. If any of them are exciting to you, please reach out and I would love to chat!</p>
<ol><li>It should be possible to build a garbage-collected programming language on top of a non-GC language, <em>and get the standard library for free!</em>
For instance, there should be a version of OCaml built on Rust that doesn't need to reimplement <code>Vec</code> or <code>HashMap</code>. See: <q><a href="https://willcrichton.net/notes/gradual-programming/">Gradual Programming</a></q>, <q><a href="/notes/rust-the-new-llvm/">Rust: The New LLVM</a></q> and <a href="https://github.com/willcrichton/lia">willcrichton/lia</a>.</li>
<li>When a CS teacher gets 100 solutions from students to a new assignment, the teacher should have tools that help them explore the commonalities and differences between solutions. I worked on this a bit <a href="#def-structure-classification" class="ref">[6]</a>. See also <a href="https://web.stanford.edu/~cpiech/bio/papers/generativeGrading.pdf">"Generative Grading: Neural Approximate Parsing for Automated Student Feedback"</a> for another cool concept in this space.</li>
<li>Trait-based languages like Rust have a <a href="https://sdleffler.github.io/RustTypeSystemTuringComplete/">Turing-complete</a> logic-programming-esque computation model embedded into their type system. I built <a href="https://github.com/willcrichton/tyrade">Tyrade</a> to show that it's possible to translate a sensible functional language into traits. But the translation is limited and I never formally proved the kind of relationship between these languages.</li>
<li>Probabilistic programming languages offer an unprecedented new capability to model problems involving uncertainty. But most PPL texts focus on teaching the mechanics of the language rather than how to map a domain task into a probabilistic program. Can we systematically describe a translation from uncertain tasks to probabilistic programs? See: <a href="https://willcrichton.net/notes/compiling-knowledge-probability/">Compiling Knowledge into Probabilistic Programs</a>.</li>
<li>Programmers often intuit that a particular API has a more direct mapping to a domain than another API, such as how many Python libraries are marketed as <q><a href="https://requests.readthedocs.io/en/latest/">for humans</a></q>. How can we quantify the concept of <q>direct mapping</q>? For example, I created the <a href="https://willcrichton.net/expressiveness-benchmark/">Expressiveness Benchmark</a> as a first pass on this question for tabular data processing APIs. Here's a <em>really</em> cool idea: imagine if you (1) embedded a bunch of APIs into a theorem prover, (2) implemented the same task in each API, and (3) wrote a proof of correctness for each implementation. Does the smallest proof corresponds to the most direct mapping?</li>
<li>Intro to discrete math and intro to probability courses share the same problem: students get caught up in the syntax, and then fail to understand the underlying concepts. (Example: what is the type of the <span><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">P</span></span></span></span></span> operator in probability?) Is it possible to improve students' learning experience with the introduction of a theorem prover or probabilistic programming language, respectively? For example, see <a href="https://leanprover.github.io/logic_and_proof/">Logic and Proof</a>, a logic textbook written using <a href="https://leanprover.github.io/">Lean</a>, and the <a href="https://www.media.mit.edu/projects/letschance/people/">Let's Chance</a> project from MIT Media Lab.</li>
<li>When programmers have questions about an API, they only use documentation and StackOverflow, rarely looking at the source code. That's not unreasonable: production-grade libraries have multiple layers of abstraction that make it hard to explore code. What if we equipped programmers with spelunking tools that could break through these abstractions? For example, I worked on <a href="https://github.com/willcrichton/inliner">Inliner</a>, a tool that uses source-to-source compiler optimizations to show how a library works in the context of an example. See also: <a href="https://ieeexplore.ieee.org/abstract/document/263907"><q>Partial evaluation as an aid to the comprehension of Fortran programs</q></a> and <a href="https://ieeexplore.ieee.org/abstract/document/601266"><q>Amorphous program slicing</q></a>.</li>
<li>Scientists learning to program in R have to deal with the language's god-awful ergonomics and error messages. How can tooling provide contextual assistance to help learners better understand how the langauge works? I built a prototype <a href="https://github.com/willcrichton/r-autota">Auto TA</a> for RStudio which learners seemed to really enjoy.</li>
<li>System designers have a vocabulary of common system components that recur across domains: state machines, event registries, access control, so on. I've always thought that <q>design patterns</q> should be articulated in terms of these kinds of components, not stuff like a <q>visitor</q>. For example, I wrote a mini-book <a href="https://willcrichton.net/rust-api-type-patterns/">Type-Driven API Design in Rust</a> that shows how to idiomatically express system components in Rust, and what mistakes you can catch at compile-time with careful design. But I think a more systematic enumeration of these kinds of system idioms would be really interesting. See also: <a href="https://en.wikipedia.org/wiki/Domain-driven_design">domain-driven design</a>.</li>
<li>For sufficiently well-defined and low-level programming tasks, it should be possible to build a probabilistic cognitive model that could accurately predict a person's behavior in solving the task. For example, after publishing <q>The Role of Working Memory in Program Tracing</q> <a href="#def-tracing-wm" class="ref">[5]</a>, I explored the idea of modeling a person as a <q>lossy</q> interpreter, and whether you could tune the lossiness parameters to explain the range of observed human traces. The models actually worked, although I never figured out what a useful application of such a cognitive model would be. Maybe you can!</li></ol></div></section><div class="logger"></div></div><div class="portal"></div></div></div><script src="./index.mjs" type="module"></script></body></html>