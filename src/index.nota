%(export let metadata = {
  title: "Will Crichton"
})
%(import "../css/index.scss")

@header{
  @div{
    @div{@h1{Will Crichton}}
    @div{@img[className="profile"][width=200][src="/assets/img/headshot.jpg"]}
  }
  @div{
    @div[className="links"]{
      @a[className="text"][href="mailto:wcrichto@brown.edu"]{wcrichto\@brown.edu}
      @a[className="text"][href="/assets/pdf/WillCrichton_CV.pdf"]{CV}
      @a[href="https://twitter.com/tonofcrates"]{@img[src="/assets/img/icon-twitter.png"]}
      @a[href="https://github.com/willcrichton/"]{@img[src="/assets/img/icon-github.png"]}
    }
    @div{
      @p{
        I am a computer scientist that designs principled, practical systems to amplify the intelligence of programmers. My research spans programming languages (PL) and human-computer interaction (HCI) with influences from system design, cognitive psychology, and learning science.
      }
      @p{I am currently a postdoc at Brown University advised by @a[href="https://cs.brown.edu/~sk/"]{Shriram Krishnamurthi}, working on making @a[href="https://rust-book.cs.brown.edu/"]{Rust easier to learn}. I completed my Ph.D. at Stanford University advised by @a[href="https://graphics.stanford.edu/~hanrahan/"]{Pat Hanrahan} and @a[href="http://graphics.stanford.edu/~maneesh/"]{Maneesh Agrawala}.}
    }
  }
}

%(let lp = "(")
%(let rp = ")")

@section[className="callout-wrapper"]{@div[className="callout"]{
  @strong{I am on the job market for a tenure-track research professorship.} You can read a draft of my 
  research statement #lp@a[href="/assets/html/WillCrichton_ResearchStatement.html"]{html}, @a[href="/assets/pdf/WillCrichton_ResearchStatement.pdf"]{pdf}#rp,
  teaching statement #lp@a[href="/assets/html/WillCrichton_TeachingStatement.html"]{html}, @a[href="/assets/pdf/WillCrichton_TeachingStatement.pdf"]{pdf}#rp,
  diversity statement #lp@a[href="/assets/html/WillCrichton_DiversityStatement.html"]{html}, @a[href="/assets/pdf/WillCrichton_DiversityStatement.pdf"]{pdf}#rp,
  and curriculum vitae #lp@a[href="/assets/pdf/WillCrichton_CV.pdf"]{pdf}#rp.
}}

@section[className="portfolio shaded"]{
  %(let Grid = ({children, gap}) => @div[className=`grid gap-${gap || "1rem"}`]{#children})
  @p{In my research, I build @em{theories} and @em{systems} about programming. A theory examines a concept in a simplified setting where its properties can be identified via logical or statistical analysis. A system applies theory to a real-world setting where unexpected constraints and engineering concerns influence the theory's application.}
  @Grid[gap="2rem"]{
    %(let theories = [
      ["infoflow", @p{I developed an algorithm for using ownership types to statically & modularly analyze information flow, and proved its soundness as noninterference @Ref{infoflow}.}],
      ["memory", @p{I ran experiments that demonstrated how working memory limits a person's ability to remember the value of variables while program tracing @Ref{tracing-wm}.}],
      ["docgen", @p{I articulated a design space for documentation generators based on the information needs of developers @Ref{docgen-infovis}.}],
      ["cluster", @p{I demonstrated that machine learning models can accurately classify a program's high-level structure @Ref{structure-classification}.}]
    ])
    @div[className="theories"]{
      @h2{Theories}
      @Grid{
        #(theories.map(([name, desc], i) => @div[key=i]{
          @img[src=`/assets/img/theory-${name}.jpg`]
          #desc
        }))
      }
    }

    %(let systems = [
      ["flowistry", @p{I built @a[href="https://github.com/willcrichton/flowistry/"]{Flowistry}, a static information flow analysis for Rust, to help programmers identify code unrelated to their current task @Ref{infoflow}.}],
      ["cs242", @p{I redesigned @a[href="https://stanford-cs242.github.io/f19/"]{CS 242}, a graduate-level course on programming languages, to help students better understand how PL theory works in the real world @Ref{plclass}.}],
      ["rustdoc", @p{I extended @a[href="https://doc.rust-lang.org/rustdoc"]{Rustdoc} to help programmers learn new APIs by @a[href="https://twitter.com/wcrichton/status/1456112165744615426"]{automatically linking documentation to code examples}.}],
      ["nota", @p{I created @a[href="https://nota-lang.org/"]{Nota}, a document language for the browser, to make a world where I never have to write LaTeX again @Ref{nota}.}]
    ])
    @div[className="projects"]{
      @h2{Systems}
      @Grid{
        #(systems.map(([name, desc], i) => @div[key=i]{
          @img[src=`/assets/img/system-${name}.jpg`]
          #desc
        }))
      }
  }
  }
}

%(let pubs = [
  {
    name: "document-calculus",
    paper: "https://arxiv.org/abs/2310.04368",
    github: "https://github.com/cognitive-engineering-lab/document-calculus",
    title: "A Core Calculus for Documents",
    authors: ["Will Crichton", "Shriram Krishnamurthi"],
    venue: "POPL",
    year: 2024,
    kind: "conference",  
    upcoming: true
  },
  {
    name: "design-patterns",
    paper: "https://arxiv.org/abs/2307.07069",
    title: "Typed Design Patterns for the Functional Era",
    authors: ["Will Crichton"],
    venue: "FUNARCH @ ICFP",
    year: 2023,
    kind: "workshop",    
  },
  {
    name: "aquascope",
    paper: "https://arxiv.org/abs/2309.04134",
    github: "https://github.com/cognitive-engineering-lab/aquascope",
    title: "A Grounded Conceptual Model for Ownership Types in Rust",
    authors: ["Will Crichton", "Gavin Gray", "Shriram Krishnamurthi"],
    venue: "OOPSLA",
    year: 2023,
    kind: "conference",    
  },
  /*{
    name: "infoflow-apps",
    paper: "TODO",
    title: "Applying Information Flow to Program Comprehension",
    authors: ["Will Crichton"],
    kind: "workshop",
    venue: "PLATEAU",
    year: 2021
  },*/
  {
    name: "infoflow",
    paper: "https://arxiv.org/abs/2111.13662",
    github: "https://github.com/willcrichton/flowistry",
    title: "Modular Information Flow Through Ownership",
    authors: ["Will Crichton", "Marco Patrignani", "Maneesh Agrawala", "Pat Hanrahan"],
    venue: "PLDI",
    year: 2022,
    kind: "conference"
  },
  {
    name: "nota",
    paper: "https://willcrichton.net/nota/",
    github: "https://github.com/willcrichton/nota",
    title: "A New Medium for Communicating Research on Programming Languages",
    authors: ["Will Crichton"],
    venue: "HATRA @ SPLASH",
    year: 2021,
    kind: "workshop"
  },
  {
    name: "tracing-wm",
    title: "The Role of Working Memory in Program Tracing",
    paper: "https://arxiv.org/abs/2101.06305",
    authors: ["Will Crichton", "Maneesh Agrawala", "Pat Hanrahan"],
    venue: "CHI",
    year: 2021,
    kind: "conference"
  },
  {
    name: "structure-classification",
    title: "Automating Program Structure Classification",
    paper: "https://arxiv.org/abs/2101.10087",
    github: "https://github.com/willcrichton/autoplan",
    authors: ["Will Crichton", "Georiga Gabriela Sampaio", "Pat Hanrahan"],
    venue: "SIGCSE",
    year: 2021,
    kind: "conference"
  },
  {
    title: "Analysis of Faces in a Decade of US Cable TV News",
    paper: "https://jhong93.github.io/pdf/tvnews-kdd21.pdf",
    site: "https://tvnews.stanford.edu",
    authors: "James Hong, Will Crichton, Haotian Zhang, Daniel Y. Fu, Jacob Ritchie, Jeremy Barenholtz, Ben Hannel, Xinwei Yao, Michaela Murray, Geraldine Moriba, Maneesh Agrawala, Kayvon Fatahalian".split(", "),
    venue: "KDD",
    year: 2021,
    kind: "conference"
  },
  {
    name: "docgen-infovis",
    title: "Documentation Generation as Information Visualization",
    paper: "https://arxiv.org/abs/2011.05600",
    authors: ["Will Crichton"],
    venue: "PLATEAU @ SPLASH",
    year: 2020,
    kind: "workshop",
  },
  /*{
    title: "The Usability of Ownership",
    paper: "https://arxiv.org/abs/2011.06171",
    authors: ["Will Crichton"],
    venue: "HATRA @ SPLASH",
    year: 2020,
    kind: "workshop",
  },*/
  /*{
    title: "Human-Centric Program Synthesis",
    paper: "https://arxiv.org/abs/1909.12281",
    authors: ["Will Crichton"],
    venue: "PLATEAU @ UIST",
    year: 2019,
    kind: "workshop",
  },*/
  {
    title: "Scanner: Efficient Video Analysis at Scale",
    github: "https://github.com/scanner-research/scanner",
    paper: "https://arxiv.org/abs/1805.07339",
    authors: ["Fait Poms", "Will Crichton", "Pat Hanrahan", "Kayvon Fatahalian"],
    venue: "SIGGRAPH",
    year: 2019,
    kind: "conference"
  },
  {
    title: "Rekall: Specifying Video Events using Compositions of Spatiotemporal Labels",
    paper: "https://arxiv.org/abs/1910.02993",
    authors: "Daniel Y. Fu, Will Crichton, James Hong, Xinwei Yao, Haotian Zhang, Anh Truong, Avanika Narayan, Maneesh Agrawala, Christopher RÃ©, Kayvon Fatahalian".split(", "),
    venue: "AI Systems @ SOSP",
    year: 2019,
    kind: "workshop",
  },
  {
    name: "plclass",
    title: "From Theory to Systems: A Grounded Approach to Programming Language Education",
    paper: "https://arxiv.org/abs/1904.06750",
    authors: ["Will Crichton"],
    venue: "SNAPL",
    year: 2019,
    kind: "workshop",
  },
  /*{
    title: "Identifying Barriers to Adoption for Rust through Online Discourse",
    paper: "https://arxiv.org/abs/1901.01001",
    authors: ["Anna Zeng", "Will Crichton"],
    venue: "PLATEAU @ SPLASH",
    year: 2018,
    kind: "workshop",
  }*/
])

%(let Publication = ({pub, index}) =>
  @Definition[block][name=pub.name][label=@{\[#index\]}]{@div[className="pub"]{
    @div[className="pub-title"]{
      @a[href=pub.paper]{#(pub.title).}
    }
    @div{@p[className="pub-authors"]{
      %(let me = "Will Crichton")
      #(pub.authors.map((a, i) => {
        let author = a == me ? @span[key=a][className="author-me"]{#a} : a;
        if (pub.authors.length == 1) {
          return author;
        } else {
          return i == pub.authors.length - 1
            ? @{ and #author}
            : @{#author, };
          }
        })).
    }}
    @div{@p{
      #(pub.venue ? @{#(pub.venue) #(pub.year) #(pub.upcoming ? "(to appear)" : "")} : @{Under submission}).
    }}
  }})

@section[className="publications"]{
  @h2{Selected Publications}

  @h3{Conference publications}

  #(pubs
    .map((pub, i) => [pub, i])
    .filter(([p]) => p.kind == "conference")
    .map(([pub, i]) => @Publication[key=i][pub=pub][index=i]))

  @h3{Workshop publications}
  
  #(pubs
    .map((pub, i) => [pub, i])
    .filter(([p]) => p.kind == "workshop")
    .map(([pub, i]) => @Publication[key=i][pub=pub][index=i]))
}


@section[className="ideas shaded"]{@div{
  @h2[id="good-ideas-for-free"]{Good Ideas For Free}
  @p[style={marginTop: '1rem'}]{Here are some ideas that I worked on a bit, but haven't had time to keep exploring. If any of them are exciting to you, please reach out and I would love to chat!}
  @ol{
    @li{It should be possible to build a garbage-collected programming language on top of a non-GC language, @em{and get the standard library for free!}
    For instance, there should be a version of OCaml built on Rust that doesn't need to reimplement @code{Vec} or @code{HashMap}. See: @q{@a[href="https://willcrichton.net/notes/gradual-programming/"]{Gradual Programming}}, @q{@a[href="/notes/rust-the-new-llvm/"]{Rust: The New LLVM}} and @a[href="https://github.com/willcrichton/lia"]{willcrichton/lia}.}
    @li{When a CS teacher gets 100 solutions from students to a new assignment, the teacher should have tools that help them explore the commonalities and differences between solutions. I worked on this a bit @Ref{structure-classification}. See also @a[href="https://web.stanford.edu/~cpiech/bio/papers/generativeGrading.pdf"]{"Generative Grading: Neural Approximate Parsing for Automated Student Feedback"} for another cool concept in this space.}
    @li{Trait-based languages like Rust have a @a[href="https://sdleffler.github.io/RustTypeSystemTuringComplete/"]{Turing-complete} logic-programming-esque computation model embedded into their type system. I built @a[href="https://github.com/willcrichton/tyrade"]{Tyrade} to show that it's possible to translate a sensible functional language into traits. But the translation is limited and I never formally proved the kind of relationship between these languages.}
    @li{Probabilistic programming languages offer an unprecedented new capability to model problems involving uncertainty. But most PPL texts focus on teaching the mechanics of the language rather than how to map a domain task into a probabilistic program. Can we systematically describe a translation from uncertain tasks to probabilistic programs? See: @a[href="https://willcrichton.net/notes/compiling-knowledge-probability/"]{Compiling Knowledge into Probabilistic Programs}.}
    @li{Programmers often intuit that a particular API has a more direct mapping to a domain than another API, such as how many Python libraries are marketed as @q{@a[href="https://requests.readthedocs.io/en/latest/"]{for humans}}. How can we quantify the concept of @q{direct mapping}? For example, I created the @a[href="https://willcrichton.net/expressiveness-benchmark/"]{Expressiveness Benchmark} as a first pass on this question for tabular data processing APIs. Here's a @em{really} cool idea: imagine if you (1) embedded a bunch of APIs into a theorem prover, (2) implemented the same task in each API, and (3) wrote a proof of correctness for each implementation. Does the smallest proof corresponds to the most direct mapping?}
    @li{Intro to discrete math and intro to probability courses share the same problem: students get caught up in the syntax, and then fail to understand the underlying concepts. (Example: what is the type of the @${P} operator in probability?) Is it possible to improve students' learning experience with the introduction of a theorem prover or probabilistic programming language, respectively? For example, see @a[href="https://leanprover.github.io/logic_and_proof/"]{Logic and Proof}, a logic textbook written using @a[href="https://leanprover.github.io/"]{Lean}, and the @a[href="https://www.media.mit.edu/projects/letschance/people/"]{Let's Chance} project from MIT Media Lab.}
    @li{When programmers have questions about an API, they only use documentation and StackOverflow, rarely looking at the source code. That's not unreasonable: production-grade libraries have multiple layers of abstraction that make it hard to explore code. What if we equipped programmers with spelunking tools that could break through these abstractions? For example, I worked on @a[href="https://github.com/willcrichton/inliner"]{Inliner}, a tool that uses source-to-source compiler optimizations to show how a library works in the context of an example. See also: @a[href="https://ieeexplore.ieee.org/abstract/document/263907"]{@q{Partial evaluation as an aid to the comprehension of Fortran programs}} and @a[href="https://ieeexplore.ieee.org/abstract/document/601266"]{@q{Amorphous program slicing}}.}
    @li{Scientists learning to program in R have to deal with the language's god-awful ergonomics and error messages. How can tooling provide contextual assistance to help learners better understand how the langauge works? I built a prototype @a[href="https://github.com/willcrichton/r-autota"]{Auto TA} for RStudio which learners seemed to really enjoy.}
    @li{System designers have a vocabulary of common system components that recur across domains: state machines, event registries, access control, so on. I've always thought that @q{design patterns} should be articulated in terms of these kinds of components, not stuff like a @q{visitor}. For example, I wrote a mini-book @a[href="https://willcrichton.net/rust-api-type-patterns/"]{Type-Driven API Design in Rust} that shows how to idiomatically express system components in Rust, and what mistakes you can catch at compile-time with careful design. But I think a more systematic enumeration of these kinds of system idioms would be really interesting. See also: @a[href="https://en.wikipedia.org/wiki/Domain-driven_design"]{domain-driven design}.}
    @li{For sufficiently well-defined and low-level programming tasks, it should be possible to build a probabilistic cognitive model that could accurately predict a person's behavior in solving the task. For example, after publishing @q{The Role of Working Memory in Program Tracing} @Ref{tracing-wm}, I explored the idea of modeling a person as a @q{lossy} interpreter, and whether you could tune the lossiness parameters to explain the range of observed human traces. The models actually worked, although I never figured out what a useful application of such a cognitive model would be. Maybe you can!}
  }
}}