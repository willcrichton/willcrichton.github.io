<!DOCTYPE html>
<!--
 _    _ _ _ _   _____      _      _     _
| |  | (_) | | /  __ \    (_)    | |   | |
| |  | |_| | | | /  \/_ __ _  ___| |__ | |_ ___  _ __
| |/\| | | | | | |   | '__| |/ __| '_ \| __/ _ \| '_ \
\  /\  / | | | | \__/\ |  | | (__| | | | || (_) | | | |
 \/  \/|_|_|_| \_____/_|  |_|\___|_| |_|\__\___/|_| |_|
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description"
          content="To demonstrate the value of Rust's memory safety rules, I contrast the implementation of a simple vector library in C and Rust, highlighting where and how Rust's static analysis can prevent tricky memory errors.">
    
    
    <title>
      
      Memory Safety in Rust: A Case Study with C | Will Crichton
      
    </title>
    
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,500,700,700i,900" rel="stylesheet">
    <link rel="stylesheet" href="/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/css/tango.css" />
    <link rel="stylesheet" href="/css/main.css" />
  </head>
  <body>
    <div class="container note">
  <h1 class="site-title"><a href="/notes">&Notepad</a></h1>
  <h1>
    
    Memory Safety in Rust: <br />A Case Study with C
    
  </h1>
  <div class="date">
    
    Will Crichton
    
    &nbsp; &mdash; &nbsp;
    February 2, 2018
  </div>
  <div class="abstract">To demonstrate the value of Rust's memory safety rules, I contrast the implementation of a simple vector library in C and Rust, highlighting where and how Rust's static analysis can prevent tricky memory errors.</div>
  <h2 id="introduction">Introduction</h2>

<p>In all programming that uses memory, we desire two program properties:</p>
<ol>
  <li><strong>Memory safety</strong> is the property of a program where memory pointers used always point to valid memory<sup id="fnref:0"><a href="#fn:0" class="footnote">1</a></sup>, i.e. allocated and of the correct type/size. Memory safety is a <em>correctness</em> issue—a memory unsafe program may crash  or produce nondeterministic output depending on the bug.</li>
  <li><strong>Memory containment</strong> (a term of my own invention<sup id="fnref:1"><a href="#fn:1" class="footnote">2</a></sup>) is the property of a program where memory does not leak, i.e. if a piece of memory is allocated, either it is reachable from the root set of the program, or it will be deallocated eventually. Memory containment is a <em>performance</em> issue—a leaky program may eventually run out of memory<sup id="fnref:2"><a href="#fn:2" class="footnote">3</a></sup>.</li>
</ol>

<p>In garbage-collected (GC) languages (e.g. Python and Java), memory safety is guaranteed for all data allocated within the language runtime, assuming a correct implementation of the garbage collector. Memory containment is guaranteed for <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">tracing garbage collectors</a> (like Java), but not necessarily for <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting garbage collectors</a> (like Python).</p>

<p>In non-GC languages, i.e. low-level systems languages like C, C++ and Rust, these memory properties must either be guaranteed by the compiler via static analysis (C++ RAII, Rust’s borrow checker), or they must be carefully managed by the programmer at runtime (<code class="highlighter-rouge">malloc</code>/<code class="highlighter-rouge">free</code>, <code class="highlighter-rouge">new</code>/<code class="highlighter-rouge">delete</code>). In particular, C is famous for being a language of footguns, as it offers few built-in constructs to protect the programmer against the dangers of manual memory management.</p>

<p>Many systems programmers and blog posts out there will warn of these hazards, but frequently not in great detail. It is a worthwhile exercise to work through an example of moderate complexity to understand the depth of problems that can occur when dealing with memory in C, and to appreciate how modern static analysis tools can prevent such bugs. Below, I have provided an implementation of a vector library (or resizable array) specialized for integers written in C. It contains at least 7 bugs relating to the properties of memory safety and containment. Take a few minutes to find them, and then we will compare it with an equivalent Rust implementation<sup id="fnref:3"><a href="#fn:3" class="footnote">4</a></sup>.</p>

<h2 id="c-implementation">C implementation</h2>

<p><strong>Disclaimer: this is a contrived example intended to illustrate how memory errors can occur. Some combination of gcc flags, careful reading, gdb, and Valgrind will catch the bugs. An experienced C programmer would not probably not write this… but they might make some of the same mistakes!</strong></p>

<p><em><a href="https://gist.github.com/willcrichton/4d83754cc3c355e10e6060dfb84cc0f9">Gist link for mobile users.</a></em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
</span>
<span class="c1">// There are at least 7 bugs relating to memory on this snippet.</span>
<span class="c1">// Find them all!</span>

<span class="c1">// Vec is short for "vector", a common term for a resizable array.</span>
<span class="c1">// For simplicity, our vector type can only hold ints.</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>     <span class="c1">// Pointer to our array on the heap</span>
  <span class="kt">int</span>  <span class="n">length</span><span class="p">;</span>   <span class="c1">// How many elements are in our array</span>
  <span class="kt">int</span>  <span class="n">capacity</span><span class="p">;</span> <span class="c1">// How many elements our array can hold</span>
<span class="p">}</span> <span class="n">Vec</span><span class="p">;</span>

<span class="n">Vec</span><span class="o">*</span> <span class="nf">vec_new</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vec_push</span><span class="p">(</span><span class="n">Vec</span><span class="o">*</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">new_capacity</span> <span class="o">=</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">new_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">new_capacity</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">new_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">new_capacity</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="o">++</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vec_free</span><span class="p">(</span><span class="n">Vec</span><span class="o">*</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Vec</span><span class="o">*</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">vec_new</span><span class="p">();</span>
  <span class="n">vec_push</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">107</span><span class="p">);</span>

  <span class="kt">int</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">vec_push</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">110</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
  <span class="n">vec_free</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Don’t look past here until you’re ready to see the answers.</strong></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p>Let’s review. Here’s the bugs:</p>
<ol>
  <li>
    <p><strong><code class="highlighter-rouge">vec_new</code>: <code class="highlighter-rouge">vec</code> is stack-allocated.</strong> This is an example of a <em>dangling pointer</em>. The line <code class="highlighter-rouge">Vec vec;</code> allocates the struct on the current stack frame and returns a pointer to that struct, however the stack frame is deallocated when the function returns, so any subsequent use of the pointer is invalid. A proper fix is to either heap allocate (<code class="highlighter-rouge">malloc(sizeof(Vec))</code>) or change the type signature to return the struct itself, not a pointer.</p>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">vec_new</code>: initial capacity is 0.</strong> When <code class="highlighter-rouge">vec_push</code> is called, the capacity will double, but <code class="highlighter-rouge">2 * 0 = 0</code>, resulting in no additional memory being allocated, so space for at least 1 element needs to be allocated up front.</p>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">vec_push</code>: incorrect call to <code class="highlighter-rouge">malloc</code>.</strong> The argument to malloc is the size of memory in bytes to allocate, however <code class="highlighter-rouge">new_capacity</code> is simply the number of integers. We need to <code class="highlighter-rouge">malloc(sizeof(int) * new_capacity)</code>.</p>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">vec_push</code>: missing free on resize.</strong> When the resize occurs, we reassign <code class="highlighter-rouge">vec-&gt;data</code> without freeing the old data pointer, resulting in a memory leak.</p>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">vec_free</code>: incorrect ordering on the <code class="highlighter-rouge">free</code>s.</strong> After freeing the vector container, the <code class="highlighter-rouge">vec-&gt;data</code> pointer is no longer valid. We should free the data pointer and then the container.</p>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">main</code>: double free of <code class="highlighter-rouge">vec-&gt;data</code>.</strong> We should not be freeing the vector’s data twice, instead only letting <code class="highlighter-rouge">vec_free</code> do the freeing.</p>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">main</code>: iterator invalidation of <code class="highlighter-rouge">n</code>.</strong> This is the most subtle bug of the lot. We start by taking a pointer to the first element in the vector. However, after calling <code class="highlighter-rouge">vec_push</code>, this causes a resize to occur, freeing the old data and allocating a new array. Hence, our old <code class="highlighter-rouge">n</code> is now a dangling pointer, and dereferencing it in the <code class="highlighter-rouge">printf</code> is memory unsafe. This is a special case of a general problem called iterator invalidation, where a pointer to a container is invalidated when the container is modified.</p>
  </li>
</ol>

<p>Wow! We managed to pack a lot of bugs into a single program. Still, this program is valid C code; it will successfully compile (although a few of the bugs <em>will</em> at least raise warnings). Now let’s see what happens if we try to implement the same code in Rust.</p>

<h2 id="rust-implementation">Rust implementation</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec2</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">isize</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">capacity</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Vec2</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Vec2</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Vec2</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">([]),</span>
            <span class="n">length</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">capacity</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<p>(We call the struct <code class="highlighter-rouge">Vec2</code> to avoid clashing with the existing <code class="highlighter-rouge">std::vec::Vec</code>.) Here, if we naively translate the previous C code, this fails to compile:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0106]: missing lifetime specifier
 --&gt; v.rs:8:17
  |
8 |     fn new() -&gt; &amp;Vec2 {
  |                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre></div></div>

<p>Rust can identify the dangling stack pointer issue without even looking at the function implementation, but instead by analyzing the type signature of the function. Since the function takes no references as input, it’s impossible to return a reference as output, since the output could only be referencing values owned inside the function. Fixing the code, we change the type signature to return an <em>owned</em> vector:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Vec2</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Vec2</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Vec2</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">length</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">capacity</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that the capacity issue is not caught by the compiler–it’s a logic error that must be identified by the programmer. That said, if we <em>didn’t</em> fix the bug, then the error would at least be an explicit out-of-bounds array error at runtime instead of a segfault for accessing out of bounds memory. Next, we implement the <code class="highlighter-rouge">push</code> method:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.length</span> <span class="o">==</span> <span class="k">self</span><span class="py">.capacity</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">new_capacity</span> <span class="o">=</span> <span class="k">self</span><span class="py">.capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">new_data</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nn">Heap</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                <span class="nf">.alloc</span><span class="p">(</span><span class="nn">Layout</span><span class="p">::</span><span class="nn">array</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new_capacity</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">())</span>
                <span class="nf">.unwrap</span><span class="p">()</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">isize</span><span class="p">;</span>
            <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_capacity</span><span class="p">))</span>
        <span class="p">};</span>

        <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.length</span> <span class="p">{</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.data</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.capacity</span> <span class="o">=</span> <span class="n">new_capacity</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="k">self</span><span class="py">.length</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.length</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This method compiles and works correctly. It does not contain an explicit <code class="highlighter-rouge">free(self.data)</code>, since Rust will automatically deallocate the old value of <code class="highlighter-rouge">self.data</code> when it is reassigned–this is based on Rust’s lifetime analysis, which determines that the lifetime of the old array ends at variable reassignment. Since the programmer does not have to ever explicitly free allocated memory, this eliminates both the associated memory leaks as well as double frees.</p>

<p>The memory allocation used here is highly unusual and non-idiomatic for Rust. Essentially all memory allocations happen either implicitly on the stack by declaring a value (e.g. <code class="highlighter-rouge">new_capacity</code> here is stack-allocated, assuming it’s not in a register), or they happen explicitly on the heap when using <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code class="highlighter-rouge">Box</code></a> or any pointer type derived from it. With these interfaces, Rust automatically allocates memory of the appropriate size and alignment. For example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">f32</span> <span class="p">}</span>
<span class="k">let</span> <span class="n">p</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Point</span><span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.2</span> <span class="p">});</span>
</code></pre></div></div>

<p>Rust determines the size of <code class="highlighter-rouge">Point</code>, and does the appropriate <code class="highlighter-rouge">malloc(sizeof(Point))</code> behind the scenes. Returning to our <code class="highlighter-rouge">push</code> method, the canonical way to allocate a variable-sized array is to use the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a> API, however it feels like cheating to use <code class="highlighter-rouge">Vec</code> to implement a vector library, so we’re doing it the hard way.</p>

<p>Here, we make a call to the memory allocator using the unstable <a href="https://doc.rust-lang.org/std/heap/struct.Heap.html"><code class="highlighter-rouge">Heap</code></a> API (this example requires nightly to compile) which provides us a raw pointer <code class="highlighter-rouge">ptr</code> to the allocated data. Raw pointers in Rust are memory regions unmanaged by the Rust compiler, which means Rust does not ensure memory safety (preventing invalid accesses) or memory containment (deallocating the pointers) for such pointers. However, Rust provides the ability to take ownership of raw pointers, which we do using <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts_mut.html"><code class="highlighter-rouge">slice::from_raw_parts_mut</code></a> and <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw"><code class="highlighter-rouge">Box::from_raw</code></a> which tells Rust to treat the memory pointer as a heap-allocated array. After transferring ownership, assuming the memory is valid and of the right size/type, Rust applies its usual memory safety and containment checks.</p>

<p>Notably, in order to perform these operations, we had to explicitly mark the code as <code class="highlighter-rouge">unsafe</code>. This is valuable since if our Rust program were to segfault due to an incorrect implementation of unsafe code, it is much easier to debug by only looking at the relevant unsafe code, rather than consider bugs that could span an entire codebase.</p>

<p>We do not have to implement the <code class="highlighter-rouge">vec_free</code> function, since Rust automatically generates the appropriate destructors for composite data structures, i.e. when the <code class="highlighter-rouge">Vec2</code> struct is deallocated, Rust knows to first deallocate the boxed array and then deallocate the container, avoiding the free ordering error as well as the double free. Lastly, if we translate the main function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span><span class="p">:</span> <span class="n">Vec2</span> <span class="o">=</span> <span class="nn">Vec2</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">107</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">isize</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vec</span><span class="py">.data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">110</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This fails to compile with the following error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0502]: cannot borrow `vec` as mutable because `vec.data[..]` is also borrowed as immutable
  --&gt; v.rs:50:5
   |
49 |     let n: &amp;isize = &amp;vec.data[0];
   |                      ----------- immutable borrow occurs here
50 |     vec.push(110);
   |     ^^^ mutable borrow occurs here
51 |     println!("{}", n);
52 | }
   | - immutable borrow ends here
</code></pre></div></div>

<p>Even the tricky iterator invalidation error is caught by the compiler due to its rules around borrowing and mutability. Taking a pointer to an element of the vector borrows the whole vector immutably, while <code class="highlighter-rouge">push</code> requires mutable access to the vector, so the compiler spots the conflict and raises an error.</p>

<p><a href="https://gist.github.com/willcrichton/761fb7c340a82aecc12cde3144515be5">Find the full Rust code here.</a></p>

<p>In sum, the guarantees provided by Rust helped us fix every memory-related error in our buggy C implementation (with the exception of the capacity issue, which at least would have had a better error message). And remember–these are <em>guarantees</em>, meaning no matter how large your code base, Rust enforces them everywhere, all the time<sup id="fnref:4"><a href="#fn:4" class="footnote">5</a></sup>. Because if we can pack so many memory errors into 50 lines of C, imagine the nightmare of a large codebase. All this, of course, comes at the price of fighting with Rust’s borrow checker, both the initial learning curve as well as working around its limitations (see: <a href="http://smallcultfollowing.com/babysteps/blog/2016/04/27/non-lexical-lifetimes-introduction/">non-lexical lifetimes</a>), but for a codebase of sufficient scale, the pain is quite likely worth the payoff.</p>

<div class="footnotes">
  <ol>
    <li id="fn:0">
      <p>I’ve seen “memory safety” used to refer to any kind of memory-related bug (e.g. so says <a href="https://en.wikipedia.org/wiki/Memory_safety">Wikipedia</a>), but I think it’s more useful to distinguish between issues of correctness and performance rather than lumping them under the same term. <a href="#fnref:0" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:1">
      <p>Someone has pointed out to me that the canonical term for this is in the PL community is “safe-for-space,” so use that if you intend to Google related work. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Assuming a program properly checks for failures during memory allocation, I don’t consider a memory leak a correctness issue since it doesn’t necessarily induce a crash. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Although Rust is the language of choice, C++ also contains many constructs to help ameliorate the issues contained in the C implementation–however, they are usually less strictly enforced by the compiler. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Memory containment is not strictly enforced, however, if one chooses to use <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">reference counting</a>. And of course, neither safety nor containment are enforced where code is explicitly marked unsafe, but in practice, this happens infrequently except around boundaries to C code. <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-16662292-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-16662292-3');
    </script>
  </body>
</html>
