<!DOCTYPE html>
<!--
 _    _ _ _ _   _____      _      _     _
| |  | (_) | | /  __ \    (_)    | |   | |
| |  | |_| | | | /  \/_ __ _  ___| |__ | |_ ___  _ __
| |/\| | | | | | |   | '__| |/ __| '_ \| __/ _ \| '_ \
\  /\  / | | | | \__/\ |  | | (__| | | | || (_) | | | |
 \/  \/|_|_|_| \_____/_|  |_|\___|_| |_|\__\___/|_| |_|
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description"
          content="I show how two domain-specific type systems, information flow control and two-party communication protocols, can be implemented in Rust using type-level programming. I explain how interesting properties of these domains can be verified at compile-time. Finally, I construct a general correspondence between type operators, logic programs, and their encoding in Rust.">
    
    
    <title>
      
      Type-level Programming in Rust | Will Crichton
      
    </title>
    
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,500,700,700i,900" rel="stylesheet">
    <link rel="stylesheet" href="/legacy/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/legacy/css/tango.css" />
    <link rel="stylesheet" href="/legacy/css/main.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
    
    
    <div style="display:none;">
      $$
      % Typography and symbols
      \newcommand{\msf}[1]{\mathsf{#1}}
      \newcommand{\ctx}{\Gamma}
      \newcommand{\qamp}{&\quad}
      \newcommand{\qqamp}{&&\quad}
      \newcommand{\Coloneqq}{::=}
      \newcommand{\proves}{\vdash}
      \newcommand{\star}[1]{#1^{*}}
      \newcommand{\eps}{\varepsilon}
      \newcommand{\nul}{\varnothing}
      \newcommand{\brc}[1]{\{{#1}\}}
      \newcommand{\binopm}[2]{#1~\bar{\oplus}~#2}
      \newcommand{\mag}[1]{|{#1}|}
      \newcommand{\aequiv}{\equiv_\alpha}
      \newcommand{\semi}[2]{{#1};~{#2}}
      % Untyped lambda calculus
      \newcommand{\fun}[2]{\lambda ~ {#1} ~ . ~ {#2}}
      \newcommand{\app}[2]{#1 ~ #2}
      \newcommand{\fix}[3]{\msf{fix}~({#1} : {#2}) ~ . ~ #3 }
      \newcommand{\truet}{\msf{true}}
      \newcommand{\falset}{\msf{false}}
      \newcommand{\define}[2]{{#1} \triangleq {#2}}

      % Typed lambda calculus - expressions
      \newcommand{\funt}[3]{\lambda ~ \left(#1 : #2\right) ~ . ~ #3}
      \newcommand{\lett}[4]{\msf{let} ~ \hasType{#1}{#2} = #3 ~ \msf{in} ~ #4}
      \newcommand{\letrec}[4]{\msf{letrec} ~ \hasType{#1}{#2} = #3 ~ \msf{in} ~ #4}a
      \newcommand{\ift}[3]{\msf{if} ~ {#1} ~ \msf{then} ~ {#2} ~ \msf{else} ~ {#3}}
      \newcommand{\rec}[5]{\msf{rec}(#1; ~ #2.#3.#4)(#5)}
      \newcommand{\case}[5]{\msf{case} ~ {#1} ~ \{ L(#2) \to #3 \mid R(#4) \to #5 \}}
      \newcommand{\pair}[2]{\left({#1},~{#2}\right)}
      \newcommand{\proj}[2]{#1 . #2}
      \newcommand{\inj}[3]{\msf{inj} ~ #1 = #2 ~ \msf{as} ~ #3}
      \newcommand{\letv}[3]{\msf{let} ~ {#1} = {#2} ~ \msf{in} ~ {#3}}
      \newcommand{\fold}[2]{\msf{fold}~{#1}~\msf{as}~{#2}}
      \newcommand{\unfold}[1]{\msf{unfold}~{#1}}
      \newcommand{\poly}[2]{\Lambda~{#1}~.~ #2}
      \newcommand{\polyapp}[2]{{#1}~\left[{#2}\right]}
      \newcommand{\export}[3]{\msf{export}~ #1 ~\msf{without}~{#2}~\msf{as}~ #3}
      \newcommand{\import}[4]{\msf{import} ~ ({#1}, {#2}) = {#3} ~ \msf{in} ~ #4}

      % Typed lambda calculus - types
      \newcommand{\tnum}{\msf{num}}
      \newcommand{\tstr}{\msf{string}}
      \newcommand{\tint}{\msf{int}}
      \newcommand{\tbool}{\msf{bool}}
      \newcommand{\tfun}[2]{#1 \rightarrow #2}
      \newcommand{\tprod}[2]{#1 \times #2}
      \newcommand{\tsum}[2]{#1 + #2}
      \newcommand{\trec}[2]{\mu~{#1}~.~{#2}}
      \newcommand{\tvoid}{\msf{void}}
      \newcommand{\tunit}{\msf{unit}}
      \newcommand{\tpoly}[2]{\forall~{#1}~.~{#2}}
      \newcommand{\tmod}[2]{\exists ~ {#1} ~ . ~ #2}

      % WebAssembly
      \newcommand{\wconst}[1]{\msf{i32.const}~{#1}}
      \newcommand{\wbinop}[1]{\msf{i32}.{#1}}
      \newcommand{\wgetlocal}[1]{\msf{get\_local}~{#1}}
      \newcommand{\wsetlocal}[1]{\msf{set\_local}~{#1}}
      \newcommand{\wgetglobal}[1]{\msf{get\_global}~{#1}}
      \newcommand{\wsetglobal}[1]{\msf{set\_global}~{#1}}
      \newcommand{\wload}{\msf{i32.load}}
      \newcommand{\wstore}{\msf{i32.store}}
      \newcommand{\wsize}{\msf{memory.size}}
      \newcommand{\wgrow}{\msf{memory.grow}}
      \newcommand{\wunreachable}{\msf{unreachable}}
      \newcommand{\wblock}[1]{\msf{block}~{#1}}
      \newcommand{\wloop}[1]{\msf{loop}~{#1}}
      \newcommand{\wbr}[1]{\msf{br}~{#1}}
      \newcommand{\wbrif}[1]{\msf{br\_if}~{#1}}
      \newcommand{\wreturn}{\msf{return}}
      \newcommand{\wcall}[1]{\msf{call}~{#1}}
      \newcommand{\wlabel}[2]{\msf{label}~\{#1\}~{#2}}
      \newcommand{\wframe}[2]{\msf{frame}~({#1}, {#2})}
      \newcommand{\wtrapping}{\msf{trapping}}
      \newcommand{\wbreaking}[1]{\msf{breaking}~{#1}}
      \newcommand{\wreturning}[1]{\msf{returning}~{#1}}
      \newcommand{\wconfig}[5]{\{\msf{module}{:}~{#1};~\msf{mem}{:}~{#2};~\msf{locals}{:}~{#3};~\msf{stack}{:}~{#4};~\msf{instrs}{:}~{#5}\}}
      \newcommand{\wfunc}[4]{\{\msf{params}{:}~{#1};~\msf{locals}{:}~{#2};~\msf{return}~{#3};~\msf{body}{:}~{#4}\}}
      \newcommand{\wmodule}[1]{\{\msf{funcs}{:}~{#1}\}}
      \newcommand{\wcg}{\msf{globals}}
      \newcommand{\wcf}{\msf{funcs}}
      \newcommand{\wci}{\msf{instrs}}
      \newcommand{\wcs}{\msf{stack}}
      \newcommand{\wcl}{\msf{locals}}
      \newcommand{\wclab}{\msf{labels}}
      \newcommand{\wcm}{\msf{mem}}
      \newcommand{\wcmod}{\msf{module}}
      \newcommand{\wsteps}[2]{\steps{\brc{#1}}{\brc{#2}}}
      \newcommand{\with}{\underline{\msf{with}}}
      \newcommand{\wvalid}[2]{{#1} \vdash {#2}~\msf{valid}}
      \newcommand{\wif}[2]{\msf{if}~{#1}~{\msf{else}}~{#2}}
      \newcommand{\wfor}[4]{\msf{for}~(\msf{init}~{#1})~(\msf{cond}~{#2})~(\msf{post}~{#3})~{#4}}
      % assign4.3 custom
      \newcommand{\wtry}[2]{\msf{try}~{#1}~\msf{catch}~{#2}}
      \newcommand{\wraise}{\msf{raise}}
      \newcommand{\wraising}[1]{\msf{raising}~{#1}}
      \newcommand{\wconst}[1]{\msf{i32.const}~{#1}}
      \newcommand{\wbinop}[1]{\msf{i32}.{#1}}
      \newcommand{\wgetlocal}[1]{\msf{get\_local}~{#1}}
      \newcommand{\wsetlocal}[1]{\msf{set\_local}~{#1}}
      \newcommand{\wgetglobal}[1]{\msf{get\_global}~{#1}}
      \newcommand{\wsetglobal}[1]{\msf{set\_global}~{#1}}
      \newcommand{\wload}{\msf{i32.load}}
      \newcommand{\wstore}{\msf{i32.store}}
      \newcommand{\wsize}{\msf{memory.size}}
      \newcommand{\wgrow}{\msf{memory.grow}}
      \newcommand{\wunreachable}{\msf{unreachable}}
      \newcommand{\wblock}[1]{\msf{block}~{#1}}
      \newcommand{\wloop}[1]{\msf{loop}~{#1}}
      \newcommand{\wbr}[1]{\msf{br}~{#1}}
      \newcommand{\wbrif}[1]{\msf{br\_if}~{#1}}
      \newcommand{\wreturn}{\msf{return}}
      \newcommand{\wcall}[1]{\msf{call}~{#1}}
      \newcommand{\wlabel}[2]{\msf{label}~\{#1\}~{#2}}
      \newcommand{\wframe}[2]{\msf{frame}~({#1}, {#2})}
      \newcommand{\wtrapping}{\msf{trapping}}
      \newcommand{\wbreaking}[1]{\msf{breaking}~{#1}}
      \newcommand{\wreturning}[1]{\msf{returning}~{#1}}
      \newcommand{\wconfig}[5]{\{\msf{module}{:}~{#1};~\msf{mem}{:}~{#2};~\msf{locals}{:}~{#3};~\msf{stack}{:}~{#4};~\msf{instrs}{:}~{#5}\}}
      \newcommand{\wfunc}[4]{\{\msf{params}{:}~{#1};~\msf{locals}{:}~{#2};~\msf{return}~{#3};~\msf{body}{:}~{#4}\}}
      \newcommand{\wmodule}[1]{\{\msf{funcs}{:}~{#1}\}}
      \newcommand{\wcg}{\msf{globals}}
      \newcommand{\wcf}{\msf{funcs}}
      \newcommand{\wci}{\msf{instrs}}
      \newcommand{\wcs}{\msf{stack}}
      \newcommand{\wcl}{\msf{locals}}
      \newcommand{\wcm}{\msf{mem}}
      \newcommand{\wcmod}{\msf{module}}
      \newcommand{\wsteps}[2]{\steps{\brc{#1}}{\brc{#2}}}
      \newcommand{\with}{\underline{\msf{with}}}
      \newcommand{\wvalid}[2]{{#1} \vdash {#2}~\msf{valid}}
      % assign4.3 custom
      \newcommand{\wtry}[2]{\msf{try}~{#1}~\msf{catch}~{#2}}
      \newcommand{\wraise}{\msf{raise}}
      \newcommand{\wraising}[1]{\msf{raising}~{#1}}
      \newcommand{\wif}[2]{\msf{if}~{#1}~{\msf{else}}~{#2}}
      \newcommand{\wfor}[4]{\msf{for}~(\msf{init}~{#1})~(\msf{cond}~{#2})~(\msf{post}~{#3})~{#4}}
      \newcommand{\windirect}[1]{\msf{call\_indirect}~{#1}}

      % session types
      \newcommand{\ssend}[2]{\msf{send}~{#1};~{#2}}
      \newcommand{\srecv}[2]{\msf{recv}~{#1};~{#2}}
      \newcommand{\soffer}[4]{\msf{offer}~\{{#1}\colon({#2})\mid{#3}\colon({#4})\}}
      \newcommand{\schoose}[4]{\msf{choose}~\{{#1}\colon({#2})\mid{#3}\colon({#4})\}}
      \newcommand{\srec}[1]{\msf{label};~{#1}}
      \newcommand{\sgoto}[1]{\msf{goto}~{#1}}
      \newcommand{\dual}[1]{\overline{#1}}

      % Inference rules
      \newcommand{\inferrule}[3][]{\cfrac{#2}{#3}\;{#1}}
      \newcommand{\ir}[3]{\inferrule[\text{(#1)}]{#2}{#3}}
      \newcommand{\s}{\hspace{1em}}
      \newcommand{\nl}{\\[2em]}
      \newcommand{\evalto}{\boldsymbol{\overset{*}{\mapsto}}}
      \newcommand{\steps}[2]{#1 \boldsymbol{\mapsto} #2}
      \newcommand{\evals}[2]{#1 \evalto #2}
      \newcommand{\subst}[3]{[#1 \rightarrow #2] ~ #3}
      \newcommand{\dynJ}[2]{#1 \proves #2}
      \newcommand{\dynJC}[1]{\dynJ{\ctx}{#1}}
      \newcommand{\typeJ}[3]{#1 \proves \hasType{#2}{#3}}
      \newcommand{\typeJC}[2]{\typeJ{\ctx}{#1}{#2}}
      \newcommand{\hasType}[2]{#1 : #2}
      \newcommand{\val}[1]{#1~\msf{val}}
      \newcommand{\num}[1]{\msf{Int}(#1)}
      \newcommand{\err}[1]{#1~\msf{err}}
      \newcommand{\trans}[2]{#1 \leadsto #2}
      \newcommand{\size}[1]{\left|#1\right|}
      $$
    </div>
    
    
  </head>
  <body>
    <div class="container note">
  <h1 class="site-title"><a href="/notes">&Notepad</a></h1>
  <h1>
    
    Type-level Programming in Rust
    
  </h1>
  <div class="date">
    
    Will Crichton
    
    &nbsp; &mdash; &nbsp;
    April 24, 2020
  </div>
  <div class="abstract">I show how two domain-specific type systems, information flow control and two-party communication protocols, can be implemented in Rust using type-level programming. I explain how interesting properties of these domains can be verified at compile-time. Finally, I construct a general correspondence between type operators, logic programs, and their encoding in Rust.</div>
  <p>Typestate is the concept of encoding state machines in a programming language’s type system. While not specific to Rust, typestate has been <a href="http://cs242.stanford.edu/f19/lectures/08-2-typestate">explored</a> <a href="https://yoric.github.io/post/rust-typestate/">elsewhere</a> <a href="https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html">at length</a> in the context of Rust. Typestate boils down to four ideas:</p>

<ol>
  <li>Each state is represented as a unique type.</li>
  <li>State transitions are only available as methods for the corresponding state type.</li>
  <li>Taking a state transition returns a state machine of the new state type.</li>
  <li>State transitions invalidate old state.</li>
</ol>

<p>For example, here’s a state machine for a send-then-receive channel:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Each state is a unique type</span>
<span class="k">struct</span> <span class="n">Receiving</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Sending</span><span class="p">;</span>

<span class="c">// The state machine is parameterized by the state</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">struct</span> <span class="n">Channel</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">chan</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span>
  <span class="mi">_</span><span class="n">state</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span>
<span class="p">}</span>


<span class="c">// Methods for the state are uniquely associated with only the state</span>
<span class="k">impl</span> <span class="n">Channel</span><span class="o">&lt;</span><span class="n">Receiving</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c">// recv consumes ownership, ensuring old state is invalidated</span>
  <span class="k">fn</span> <span class="nf">recv</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Channel</span><span class="o">&lt;</span><span class="n">Sending</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">self</span><span class="py">.chan</span><span class="nf">.recv</span><span class="p">();</span>
    <span class="c">// The state type changes after executing a transition</span>
    <span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">},</span> <span class="n">msg</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Channel</span><span class="o">&lt;</span><span class="n">Sending</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Channel</span><span class="o">&lt;</span><span class="n">Receiving</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.chan</span><span class="nf">.send</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">channel_test</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">c</span><span class="p">:</span> <span class="n">Channel</span><span class="o">&lt;</span><span class="n">Sending</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Channel</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="n">c</span><span class="p">:</span> <span class="n">Channel</span><span class="o">&lt;</span><span class="n">Receiving</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.send</span><span class="p">(</span><span class="s">"hi"</span><span class="p">);</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.recv</span><span class="p">();</span>
  <span class="c">// and so on</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>There are <a href="https://news.ycombinator.com/item?id=24688233">many</a> <a href="https://www.reddit.com/r/rust/comments/gaxlm3/typelevel_programming_in_rust/fp2gjhg/">readers</a> concerned with the use of <code class="highlighter-rouge">transmute</code>. The use of <code class="highlighter-rouge">#[repr(transparent)]</code> ensures that the layout of <code class="highlighter-rouge">Channel</code> is <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent">stable across transmutations</a> of the marker type.</p>
</blockquote>

<p>This pattern works effectively for simple finite state machines, where the logic to determine the next state is straightforward. In this note, I will explore situations where determining the next state is not so simple. In the process, we’ll talk about <strong>type-level programming</strong>, or how you can use Rust’s type system to encode <strong>computations on types</strong>.</p>

<blockquote>
  <p>Part of the goal of this note is to show the value of type-level programming in practice. These same mechanisms have already been used for more esoteric purposes like <a href="https://sdleffler.github.io/RustTypeSystemTuringComplete/">showing Rust’s type system is Turing complete</a>, but I think type-level programming can really help us design better systems!</p>
</blockquote>

<h2 id="1-information-flow-control">1. Information flow control</h2>

<p>As a first example, consider a basic information flow control problem. In our program we have low security values (anyone can read them) and high security values (only authorized users can read them).</p>

<p>We represent this idea like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Each security level is a type</span>
<span class="k">struct</span> <span class="n">HighSec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">LowSec</span><span class="p">;</span>

<span class="c">// An Item wraps an arbitrary type T, associating it with a Level</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">struct</span> <span class="n">Item</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Level</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">t</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="mi">_</span><span class="n">marker</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">Level</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="c">// Constructors for building items of a particular security</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Item</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">LowSec</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">low_sec</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Item</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">LowSec</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Item</span> <span class="p">{</span> <span class="n">t</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">_</span><span class="n">marker</span><span class="p">:</span> <span class="n">PhantomData</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">high_sec</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Item</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">HighSec</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Item</span> <span class="p">{</span> <span class="n">t</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">_</span><span class="n">marker</span><span class="p">:</span> <span class="n">PhantomData</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c">// For simplicity, a naked Item can be read by anyone</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Level</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">Item</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Level</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="py">.t</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>We would like to have a vector of these items with the following property:</p>
<ul>
  <li>If all of the items are low security, anyone can read any item.</li>
  <li>If any of the items are high security, only an authorized user can read any item.</li>
</ul>

<p>For example, our vector should pass this test:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">SecureVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="nn">Item</span><span class="p">::</span><span class="nf">low_sec</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="nn">Item</span><span class="p">::</span><span class="nf">high_sec</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>         <span class="c">// v is still low sec</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>   <span class="c">// ok to read v</span>

<span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="n">hi</span><span class="p">);</span>         <span class="c">// v is now high sec</span>
<span class="c">// assert_eq!(v.get(0), 1); // can't read any more, compiler error</span>

<span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="nn">HighSecWitness</span><span class="p">::</span><span class="nf">login</span><span class="p">();</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="nf">.get_secure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span> <span class="c">// can read after login</span>
</code></pre></div></div>

<p>A basic type-state attempt looks like this. We can create and read a low-security vector:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(transparent)]</span>
<span class="k">struct</span> <span class="n">SecureVec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Level</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">items</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Level</span><span class="o">&gt;&gt;</span><span class="p">,</span>
  <span class="mi">_</span><span class="n">marker</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">Level</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">SecureVec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">LowSec</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">SecureVec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">LowSec</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">SecureVec</span> <span class="p">{</span> <span class="n">items</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="mi">_</span><span class="n">marker</span><span class="p">:</span> <span class="n">PhantomData</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="py">.items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And we can protect a high-security vector through a witness:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">HighSecWitness</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">HighSecWitness</span> <span class="p">{</span>
  <span class="c">// sprinkle some high-security authentication in here...</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">login</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">HighSecWitness</span> <span class="p">{</span> <span class="n">HighSecWitness</span> <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">SecureVec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">HighSec</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_secure</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="mi">_</span><span class="n">witness</span><span class="p">:</span> <span class="n">HighSecWitness</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="py">.items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, to the main idea: how can we implement <code class="highlighter-rouge">push</code>? There are four possible state combinations: a high/low security vector with a high/low security item. While we can implement each combination as a separate method, it’s simpler to consider the underlying logic. <code class="highlighter-rouge">push</code> should return a vector of level <code class="highlighter-rouge">max(vec_level, item_level)</code> where <code class="highlighter-rouge">max(hi, lo) = hi</code>.</p>

<p>Our goal is to encode <code class="highlighter-rouge">max</code> as a <em>type-level computation</em>, i.e. an operator on types. The high-level idea:</p>
<ul>
  <li>Traits definitions are function signatures from types to types.</li>
  <li>Trait type parameters represent inputs and associated types represent outputs.</li>
  <li>Trait implementations define individual mappings from inputs to outputs.</li>
</ul>

<p>Here are those ideas in action to compute the max security level:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Self (implicitly) is the left operand, Other is the right operand,</span>
<span class="c">// and Output is the output</span>
<span class="k">trait</span> <span class="n">ComputeMaxLevel</span><span class="o">&lt;</span><span class="n">Other</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// These impls define the core computation</span>
<span class="k">impl</span> <span class="n">ComputeMaxLevel</span><span class="o">&lt;</span><span class="n">LowSec</span><span class="o">&gt;</span>  <span class="k">for</span> <span class="n">LowSec</span>  <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">LowSec</span><span class="p">;</span>  <span class="p">}</span>
<span class="k">impl</span> <span class="n">ComputeMaxLevel</span><span class="o">&lt;</span><span class="n">HighSec</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">LowSec</span>  <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">HighSec</span><span class="p">;</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">ComputeMaxLevel</span><span class="o">&lt;</span><span class="n">LowSec</span><span class="o">&gt;</span>  <span class="k">for</span> <span class="n">HighSec</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">HighSec</span><span class="p">;</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">ComputeMaxLevel</span><span class="o">&lt;</span><span class="n">HighSec</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">HighSec</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">HighSec</span><span class="p">;</span> <span class="p">}</span>

<span class="c">// The type alias gives us a more convenient way to "call" the type operator</span>
<span class="k">type</span> <span class="n">MaxLevel</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">L</span> <span class="k">as</span> <span class="n">ComputeMaxLevel</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>The most confusing part is the <code class="highlighter-rouge">MaxLevel</code> alias. In brief: <code class="highlighter-rouge">L as ComputeMaxLevel&lt;R&gt;</code> says “treat <code class="highlighter-rouge">L</code> as the trait object <code class="highlighter-rouge">ComputeMaxLevel&lt;R&gt;</code>”. This is necessary since multiple computation traits may have associated <code class="highlighter-rouge">Output</code> with <code class="highlighter-rouge">L</code>, so the explicit cast disambiguates the <code class="highlighter-rouge">MaxLevel</code> computation from the rest.</p>
</blockquote>

<p>Here’s an example of using the type operator:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="mi">_</span> <span class="p">:</span> <span class="n">MaxLevel</span><span class="o">&lt;</span><span class="n">HighSec</span><span class="p">,</span> <span class="n">LowSec</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">HighSec</span><span class="p">;</span> <span class="c">// ok</span>
<span class="k">let</span> <span class="mi">_</span> <span class="p">:</span> <span class="n">MaxLevel</span><span class="o">&lt;</span><span class="n">LowSec</span> <span class="p">,</span> <span class="n">LowSec</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">LowSec</span><span class="p">;</span>  <span class="c">// ok</span>
<span class="k">let</span> <span class="mi">_</span> <span class="p">:</span> <span class="n">MaxLevel</span><span class="o">&lt;</span><span class="n">LowSec</span> <span class="p">,</span> <span class="n">LowSec</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">HighSec</span><span class="p">;</span> <span class="c">// type error</span>
</code></pre></div></div>

<p>Now, we can implement <code class="highlighter-rouge">SecureVec::push</code> in one method:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">VecLevel</span><span class="o">&gt;</span> <span class="n">SecureVec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">VecLevel</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="n">push</span><span class="o">&lt;</span><span class="n">ItemLevel</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Item</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">ItemLevel</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SecureVec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MaxLevel</span><span class="o">&lt;</span><span class="n">ItemLevel</span><span class="p">,</span> <span class="n">VecLevel</span><span class="o">&gt;&gt;</span>
  <span class="k">where</span>
    <span class="n">ItemLevel</span><span class="p">:</span> <span class="n">ComputeMaxLevel</span><span class="o">&lt;</span><span class="n">VecLevel</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.items</span><span class="nf">.push</span><span class="p">(</span><span class="nf">transmute</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
      <span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice the usage of <code class="highlighter-rouge">MaxLevel</code> in the return type of <code class="highlighter-rouge">push</code>. This is the key use of the type operator as a type-level computation. The other main component is the <code class="highlighter-rouge">where</code> clause: when used generically (over any possible <code class="highlighter-rouge">ItemLevel</code>), we have to use a trait bound to ensure that <code class="highlighter-rouge">ComputeMaxLevel</code> can be “called” on <code class="highlighter-rouge">ItemLevel</code>.</p>

<p>Excellent! We’ve now used a type-level computation to more abstractly specify typestate in our information flow control API. Next, we’ll look at an example with a more complex type-level program.</p>

<h2 id="2-two-party-communication-protocols">2. Two-party communication protocols</h2>

<p>When two parties synchronously communicate with each other (e.g. a client and server exchanging information), that communication protocol can be modeled as a session type. We’re going to look at session types <a href="https://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">implemented in Rust</a>. While their full implementation is beyond the scope of the post (see the linked paper or my <a href="http://cs242.stanford.edu/f19/lectures/09-1-session-types">course notes</a>), I will focus on the aspects of session types that showcase type-level programming.</p>

<p>Session types are a domain-specific language of state machines, described by this grammar:</p>

<script type="math/tex; mode=display">\begin{align*}
\msf{SessionType}~\sigma ::= \qamp \srecv{\tau}{\sigma} \qqamp \text{receive message type $\tau$} \\
\mid \qamp \ssend{\tau}{\sigma} \qqamp \text{send message type $\tau$} \\
\mid \qamp \schoose{L}{\sigma_L}{R}{\sigma_R} \qqamp \text{choose sub-protocol} \\
\mid \qamp \soffer{L}{\sigma_L}{R}{\sigma_R} \qqamp \text{offer sub-protocol} \\
\mid \qamp \srec{\sigma} \qqamp \text{label point} \\
\mid \qamp \sgoto{i} \qqamp \text{go to label} \\
\mid \qamp \eps \qqamp \text{end protocol}
\end{align*}</script>

<p>For example, this session type describes a ping server that sends and receives a ping in a loop, exiting on demand. The label/goto scheme uses <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a> to locally encode label names as integers.</p>

<script type="math/tex; mode=display">\begin{align*}
\srec{\soffer{\text{run}}{\ssend{\text{ping}}{\srecv{\text{ping}}{\sgoto{0}}}}{\text{quit}}{\eps}}
\end{align*}</script>

<p>The grammar, and this example, can be encoded in Rust like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nb">Send</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Recv</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Offer</span><span class="o">&lt;</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Choose</span><span class="o">&lt;</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Label</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Goto</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Z</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">);</span> <span class="c">// Peano encoding for natural numbers</span>
<span class="k">struct</span> <span class="n">Close</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Ping</span><span class="p">;</span>
<span class="k">type</span> <span class="n">PingServer</span> <span class="o">=</span>
  <span class="n">Label</span><span class="o">&lt;</span>
    <span class="n">Offer</span><span class="o">&lt;</span>
      <span class="nb">Send</span><span class="o">&lt;</span><span class="n">Ping</span><span class="p">,</span>
        <span class="n">Recv</span><span class="o">&lt;</span><span class="n">Ping</span><span class="p">,</span>
        <span class="n">Goto</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
      <span class="n">Close</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</code></pre></div></div>

<p>The runtime communication API uses the type-state concept as a channel whose type changes as the protocol advances. Initially, a <code class="highlighter-rouge">Chan</code> is created for the server and the client (the “dual” of the server). Here’s an example where the type annotations show the change.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">example_ping_server</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">_</span><span class="p">):</span> <span class="p">(</span><span class="n">Chan</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">PingServer</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Chan</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Dual</span><span class="o">&lt;</span><span class="n">PingServer</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Chan</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span><span class="p">:</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Offer</span><span class="o">&lt;</span><span class="mi">_</span><span class="p">,</span><span class="mi">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">()),</span> <span class="n">Offer</span><span class="o">&lt;</span><span class="mi">_</span><span class="p">,</span><span class="mi">_</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.label</span><span class="p">();</span>
  <span class="k">loop</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">=</span> <span class="k">match</span> <span class="n">c</span><span class="nf">.offer</span><span class="p">()</span> <span class="p">{</span>
      <span class="nn">Branch</span><span class="p">::</span><span class="nf">Left</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">c</span><span class="p">:</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="mi">_</span><span class="p">,</span> <span class="n">Recv</span><span class="o">&lt;</span><span class="mi">_</span><span class="p">,</span><span class="mi">_</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.send</span><span class="p">(</span><span class="n">Ping</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Ping</span><span class="p">):</span> <span class="p">(</span><span class="n">Chan</span><span class="o">&lt;</span><span class="mi">_</span><span class="p">,</span> <span class="n">Goto</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.recv</span><span class="p">();</span>
        <span class="n">c</span><span class="nf">.goto</span><span class="p">()</span>
      <span class="p">},</span>
      <span class="nn">Branch</span><span class="p">::</span><span class="nf">Right</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="n">c</span><span class="nf">.close</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that the <code class="highlighter-rouge">Chan</code> has two type arguments: an environment <code class="highlighter-rouge">Env</code> and a current action <code class="highlighter-rouge">Sigma</code>. The environment contains a list of session types generated by calls to <code class="highlighter-rouge">label</code>. When we <code class="highlighter-rouge">goto</code>, we look up the corresponding type in the <code class="highlighter-rouge">Env</code> list and make that the type of the current channel.</p>

<blockquote>
  <p>You might wonder how the methods like <code class="highlighter-rouge">c.offer()</code> and <code class="highlighter-rouge">c.recv()</code> are actually implemented. Once the session type framework is established, they aren’t very interesting — perform an operation, then transmute to the new type-state. For example, <code class="highlighter-rouge">recv</code>:</p>
  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">Recv</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span>
<span class="k">where</span>
  <span class="n">T</span><span class="p">:</span> <span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span> <span class="o">+</span> <span class="nv">'static</span><span class="p">,</span>
<span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">recv</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Chan</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.read</span><span class="p">();</span>
      <span class="p">(</span><span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>  </div>
  <p>See the <a href="https://github.com/Munksgaard/session-types/blob/master/src/lib.rs">session-types</a> crate for the full implementation if you’re interested.</p>
</blockquote>

<p>We’re going to look at two type-level operations in this framework:</p>
<ul>
  <li>Dual types: given a description of the protocol from one party’s perspective (e.g. <code class="highlighter-rouge">PingServer</code>) we can automatically generate a matching <code class="highlighter-rouge">PingClient</code> protocol. This is the <code class="highlighter-rouge">Dual&lt;PingServer&gt;</code> reference above.</li>
  <li>Labels and gotos: to implement <code class="highlighter-rouge">label</code>/<code class="highlighter-rouge">goto</code>, we need a notion of a dynamically-sized list of types that we can push, index, and change.</li>
</ul>

<h3 id="21-dual-types">2.1. Dual types</h3>

<p>The idea of a dual session type is that if I’m sending to you, you should be receiving from me. Similarly, if I offer to branch left or right, you should be choosing which branch to take. In Rust, the dual of <code class="highlighter-rouge">Send&lt;i32, Close&gt;</code> should be <code class="highlighter-rouge">Recv&lt;i32, Close&gt;</code>.</p>

<p>Dual session types are useful because they prevent errors. If you had to manually specify both halves of the protocol, you might accidentally mis-match one side.</p>

<p>We can write down an inductive procedure for generating a dual type as follows, using the notation <script type="math/tex">\dual{\sigma}</script> to mean “the dual of <script type="math/tex">\sigma</script>”.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
\dual{\ssend{\tau}{\sigma}} &= \srecv{\tau}{\dual{\sigma}} \\
\dual{\srecv{\tau}{\sigma}} &= \ssend{\tau}{\dual{\sigma}} \\
\dual{\schoose{L}{\sigma_L}{R}{\sigma_R}} &= \soffer{L}{\dual{\sigma_L}}{R}{\dual{\sigma_R}} \\
\dual{\soffer{L}{\sigma_L}{R}{\sigma_R}} &= \schoose{L}{\dual{\sigma_L}}{R}{\dual{\sigma_R}} \\
\dual{\srec{\sigma}} &= \srec{\dual{\sigma}}\\
\dual{\sgoto{i}} &= \sgoto{i} \\
\dual{\eps} &= \eps
\end{align*} %]]></script>

<p>In the context of type-level programming, <script type="math/tex">\dual{\sigma}</script> is an operator that takes as input a type, and produces a type. Like with <code class="highlighter-rouge">MaxLevel</code>, we encode that concept as a trait:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">ComputeDual</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Dual</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">S</span> <span class="k">as</span> <span class="n">ComputeDual</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
</code></pre></div></div>

<p>Unlike before, <code class="highlighter-rouge">ComputeDual</code> only takes one argument <code class="highlighter-rouge">Self</code>, so it does not need additional parameters. Like before, we use an alias to simplify later usage of the trait.</p>

<p>The key idea is that each of the logical rules above cleanly translates into a corresponding trait implementation. First, the base cases:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ComputeDual</span> <span class="k">for</span> <span class="n">Close</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Close</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">ComputeDual</span> <span class="k">for</span> <span class="n">Goto</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Goto</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To represent the inductive cases (e.g. <code class="highlighter-rouge">Send</code>), we use a <code class="highlighter-rouge">where</code> clause to perform an inductive computation. For example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">ComputeDual</span> <span class="k">for</span> <span class="nb">Send</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="k">where</span> <span class="n">S</span><span class="p">:</span> <span class="n">ComputeDual</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Recv</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Dual</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Again, compare this code to the original rule:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
\dual{\ssend{\tau}{\sigma}} &= \srecv{\tau}{\dual{\sigma}}
\end{align*} %]]></script>

<p>Usually, a <code class="highlighter-rouge">where</code> bound <em>constrains</em> a trait implementation, e.g. <code class="highlighter-rouge">ToString</code> for <code class="highlighter-rouge">Vec&lt;T&gt;</code> is only implemented where <code class="highlighter-rouge">T: ToString</code>. Here, we re-purpose the bound to <em>perform a computation</em>, i.e. inductively getting the <code class="highlighter-rouge">Dual</code> of <code class="highlighter-rouge">S</code>.</p>

<blockquote>
  <p>Note that trait bounds have the form <code class="highlighter-rouge">Type: Trait</code>, so we can’t say <code class="highlighter-rouge">S: Dual</code> as <code class="highlighter-rouge">Dual</code> is a type. We use <code class="highlighter-rouge">ComputeDual</code> in the trait bound, then <code class="highlighter-rouge">Dual&lt;S&gt;</code> when used as a type.</p>
</blockquote>

<p>As another example, here’s the Dual rule for <code class="highlighter-rouge">Choose</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="o">&gt;</span> <span class="n">ComputeDual</span> <span class="k">for</span> <span class="n">Choose</span><span class="o">&lt;</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="nb">Left</span><span class="p">:</span> <span class="n">ComputeDual</span><span class="p">,</span> <span class="nb">Right</span><span class="p">:</span> <span class="n">ComputeDual</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Offer</span><span class="o">&lt;</span><span class="n">Dual</span><span class="o">&lt;</span><span class="nb">Left</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Dual</span><span class="o">&lt;</span><span class="nb">Right</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With these rules in hand, we can now easily specify our client type:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">PingServer</span> <span class="o">=</span> <span class="n">Label</span><span class="o">&lt;</span><span class="n">Offer</span><span class="o">&lt;..&gt;&gt;</span><span class="p">;</span>
<span class="k">type</span> <span class="n">PingClient</span> <span class="o">=</span> <span class="n">Dual</span><span class="o">&lt;</span><span class="n">PingServer</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<p>That’s it! We’ve successfully encoded dual session types as a type operator in Rust.</p>

<p>At this point, you may wonder — the translation from the pretty logic to the ugly traits involves a lot of syntax. Take a look at the <a href="https://github.com/sdleffler/type-operators-rs">type-operators</a> crate for using a macro to automatically perform the translation.</p>

<h3 id="22-label-and-goto">2.2. Label and goto</h3>

<p>Our final challenge is to implement the <code class="highlighter-rouge">label</code> and <code class="highlighter-rouge">goto</code> operators. We start with the following skeleton, needing to fill in the <code class="highlighter-rouge">?</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">Label</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="c">// should push S onto Env</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">label</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Chan</span><span class="o">&lt;?</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">Goto</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="c">// should get the Nth type in Env and drop the first N items from Env</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">goto</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Chan</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We are going to encode <code class="highlighter-rouge">Env</code> as a list of session types. To do so, we need to resolve four questions:</p>
<ol>
  <li>How do we represent a list of types?</li>
  <li>How do we <code class="highlighter-rouge">push</code> to a list of types?</li>
  <li>How do we get the <script type="math/tex">n</script>-th type in a list of types?</li>
  <li>How do we drop the first <script type="math/tex">n</script> types in a list of types?</li>
</ol>

<p>Like in a functional programming language, we will use a linked-list nil/cons style to represent a type list.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">EmptyList</span> <span class="o">=</span> <span class="p">();</span>      <span class="c">// or "Nil"  if you prefer</span>
<span class="k">type</span> <span class="n">Push</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="p">);</span> <span class="c">// or "Cons" if you prefer</span>

<span class="k">type</span> <span class="n">ExampleList</span> <span class="o">=</span> <span class="n">Push</span><span class="o">&lt;</span><span class="n">Push</span><span class="o">&lt;</span><span class="n">EmptyList</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c">// ExampleList = (bool, (String, ()))</span>
</code></pre></div></div>

<p>Then to get the <script type="math/tex">n</script>-th type in a list, we can use a type-level operator encoded as a trait, using a familiar pattern:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">ComputeNth</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span><span class="p">;</span> <span class="p">}</span>
<span class="k">type</span> <span class="n">Nth</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">L</span> <span class="k">as</span> <span class="n">ComputeNth</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
</code></pre></div></div>

<p>Think for a moment about the inductive definition of <code class="highlighter-rouge">Nth</code> as you might write it in OCaml or Haskell. It probably looks something like this:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
\msf{nth}~(\tau, l)~0 &= \tau \\
\msf{nth}~(\tau, l)~i &= \msf{nth}~l~(i-1)
\end{align*} %]]></script>

<p>Just like with dual session types, we can straightforwardly encode these logical rules into trait implementations. However, because we are using a Peano encoding of the natural numbers, we’ll tweak the second rule to look like this:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
\msf{nth}~(\tau, l)~(i+1) &= \msf{nth}~l~i
\end{align*} %]]></script>

<p>Then the encoding of <code class="highlighter-rouge">Nth</code> into Rust traits becomes 1-to-1:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="n">ComputeNth</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Push</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">ComputeNth</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="n">Push</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="k">where</span> <span class="n">L</span><span class="p">:</span> <span class="n">ComputeNth</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Nth</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Similarly, we can create a function that drops the first <code class="highlighter-rouge">N</code> elements from a type list:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">ComputeDropFirst</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span><span class="p">;</span> <span class="p">}</span>
<span class="k">type</span> <span class="n">DropFirst</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">L</span> <span class="k">as</span> <span class="n">ComputeDropFirst</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;</span> <span class="n">ComputeDropFirst</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">L</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">ComputeDropFirst</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="n">Push</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">L</span><span class="p">:</span> <span class="n">ComputeDropFirst</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">DropFirst</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With these type-level operators in hand, we can finish our label and goto implementations. Now, <code class="highlighter-rouge">label</code> is a simple <code class="highlighter-rouge">Push</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">Label</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">label</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">Push</span><span class="o">&lt;</span><span class="n">S</span><span class="p">,</span> <span class="n">Env</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">goto</code> function is more complex. We need to both get the <code class="highlighter-rouge">Nth</code> element of an environment, and drop the first <code class="highlighter-rouge">N</code> elements.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">Goto</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;&gt;</span>
<span class="k">where</span> <span class="n">Env</span><span class="p">:</span> <span class="n">ComputeNth</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">ComputeDropFirst</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">goto</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">DropFirst</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Nth</span><span class="o">&lt;</span><span class="n">Env</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">transmute</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that because we use <code class="highlighter-rouge">Env</code> with two type-level operators, we have to add both as bounds combined with <code class="highlighter-rouge">+</code>.</p>

<h2 id="3-traits-as-relations">3. Traits as relations</h2>

<p>The relationship between types, traits, and logic programming has been an enduring theme in the Rust community. <a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">“Lowering Rust traits to logic”</a> and the ongoing efforts on <a href="https://github.com/rust-lang/chalk">chalk</a> both show how resolving trait bounds is equivalent to executing a logic program.</p>

<p>In this note, I tried to go in the opposite direction — showing how domain-specific type-systems, whose rules are often written as logical relations, can be lowered into Rust traits. I think this is valuable because:</p>

<ul>
  <li>
    <p>Domain-specific type systems enable powerful compile-time checks on complex properties. Checking that communication protocols are followed, or that secure information is protected, usually requires external model checkers. Here, we just need Rust!</p>
  </li>
  <li>
    <p>Encoding logic rules into Rust traits in a practical way is not obvious at first glance. There aren’t many examples of this pattern to generalize from.</p>
  </li>
</ul>

<p>For example, if we took our type operators above, we could concisely encode their logic as a logic program (using Prolog-esque syntax):</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% MaxLevel(Self, Other, Output)</span>
<span class="nv">MaxLevel</span><span class="p">(</span><span class="nv">Low</span><span class="p">,</span> <span class="nv">Low</span><span class="p">,</span> <span class="nv">Low</span><span class="p">).</span>
<span class="nv">MaxLevel</span><span class="p">(</span><span class="nv">Low</span><span class="p">,</span> <span class="nv">High</span><span class="p">,</span> <span class="nv">High</span><span class="p">).</span>
<span class="nv">MaxLevel</span><span class="p">(</span><span class="nv">High</span><span class="p">,</span> <span class="nv">Low</span><span class="p">,</span> <span class="nv">High</span><span class="p">).</span>
<span class="nv">MaxLevel</span><span class="p">(</span><span class="nv">High</span><span class="p">,</span> <span class="nv">High</span><span class="p">,</span> <span class="nv">High</span><span class="p">).</span>

<span class="c1">% Dual(Self, Output)</span>
<span class="nv">Dual</span><span class="p">(</span><span class="nv">Close</span><span class="p">,</span> <span class="nv">Close</span><span class="p">).</span>
<span class="nv">Dual</span><span class="p">(</span><span class="nv">Recv</span><span class="o">&lt;</span><span class="nv">T</span><span class="p">,</span> <span class="nv">S</span><span class="o">&gt;,</span> <span class="nv">Send</span><span class="o">&lt;</span><span class="nv">T</span><span class="p">,</span> <span class="nv">S2</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">Dual</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="nv">S2</span><span class="p">).</span>

<span class="c1">% Nth(Self, N, Output)</span>
<span class="nv">Nth</span><span class="p">(</span><span class="nv">X</span> <span class="o">::</span> <span class="nv">L</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
<span class="nv">Nth</span><span class="p">(</span><span class="nv">X</span> <span class="o">::</span> <span class="nv">L</span><span class="p">,</span> <span class="nv">I</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="nv">X2</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">Nth</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="nv">I</span><span class="p">,</span> <span class="nv">X2</span><span class="p">).</span>
</code></pre></div></div>

<p>Seeing this pattern, we can construct a general translation. A type operator is a relation with <code class="highlighter-rouge">Self</code> as the first argument, <code class="highlighter-rouge">Output</code> as the last argument, and additional arguments in between. So a general relation <code class="highlighter-rouge">Rel(Self, Arg1, .., ArgN, Output)</code> translates to:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">ComputeRel</span><span class="o">&lt;</span><span class="n">Arg1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">ArgN</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span><span class="p">;</span> <span class="p">}</span>
<span class="k">type</span> <span class="n">Rel</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="n">Arg1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">ArgN</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Self</span> <span class="k">as</span> <span class="n">Rel</span><span class="o">&lt;</span><span class="n">Arg1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">ArgN</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
</code></pre></div></div>

<p>An unconditional fact like <code class="highlighter-rouge">Rel(Tself, T1, ... TN, Tout)</code> becomes an <code class="highlighter-rouge">impl</code> block without a <code class="highlighter-rouge">where</code> clause:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ComputeRel</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">TN</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Tself</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Tout</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>And a complex conditional fact like:</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Rel</span><span class="p">(</span><span class="nv">Tself</span><span class="p">,</span> <span class="nv">T1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">TN</span><span class="p">,</span> <span class="nv">Tout</span><span class="p">)</span> <span class="p">:-</span>
  <span class="nv">OtherRel</span><span class="p">(</span><span class="nv">Tself</span><span class="p">,</span> <span class="nv">Totherout</span><span class="p">),</span> <span class="nv">Rel</span><span class="p">(</span><span class="nv">Totherout</span><span class="p">,</span> <span class="nv">T1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">TN</span><span class="p">,</span> <span class="nv">Tout</span><span class="p">).</span>
</code></pre></div></div>

<p>Becomes an <code class="highlighter-rouge">impl</code> block with a <code class="highlighter-rouge">where</code> clause:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ComputeRel</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">TN</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Tself</span>
<span class="k">where</span> <span class="n">Tself</span><span class="p">:</span> <span class="n">ComputeOtherRel</span><span class="p">,</span> <span class="n">OtherRel</span><span class="o">&lt;</span><span class="n">Tself</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">ComputeRel</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">TN</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Rel</span><span class="o">&lt;</span><span class="n">OtherRel</span><span class="o">&lt;</span><span class="n">Tself</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In drawing this connection between traits and logic programs, I hope that you might find it easier to encode new domain-specific type systems in Rust. These examples also demonstrate that there’s a lot of exciting future work in developing libraries and best practices for type-level programming!</p>

</div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-16662292-3"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());
     gtag('config', 'UA-16662292-3');
    </script>

    <!-- Mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full" type="text/javascript"></script>
    <script type="text/javascript">
     MathJax.Hub.Config({
       messageStyle: "none",
       tex2jax: {inlineMath: [['($', '$)'], ['\\(','\\)']]},
       "HTML-CSS": {
         fonts: ["TeX"]
       }
     });
     MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
       console.error(message[2]);
     });
     MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
       console.error(message[1]);
     });
    </script>
  </body>
</html>
