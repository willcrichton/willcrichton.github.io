<!DOCTYPE html>
<!--
 _    _ _ _ _   _____      _      _     _
| |  | (_) | | /  __ \    (_)    | |   | |
| |  | |_| | | | /  \/_ __ _  ___| |__ | |_ ___  _ __
| |/\| | | | | | |   | '__| |/ __| '_ \| __/ _ \| '_ \
\  /\  / | | | | \__/\ |  | | (__| | | | || (_) | | | |
 \/  \/|_|_|_| \_____/_|  |_|\___|_| |_|\__\___/|_| |_|
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description"
          content="Jupyter presents a unique programming style where the programmer can change her code while it's running, reducing the cost of mistakes and improving the interactivity of the programming process. I discuss the benefits and limitations of this approach along with the related work.">
    
    
    <title>
      
      Programming in the Debugger | Will Crichton
      
    </title>
    
    <link href="https://fonts.googleapis.com/css?family=Alegreya+Sans" rel="stylesheet">
    <link rel="stylesheet" href="/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/css/tango.css" />
    <link rel="stylesheet" href="/css/main.css" />
  </head>
  <body>
    <div class="container note">
  <h1 class="site-title"><a href="/notes">&Notepad</a></h1>
  <h1>
    
    Programming in the Debugger
    
  </h1>
  <div class="date">April 20, 2018</div>
  <div class="abstract">Jupyter presents a unique programming style where the programmer can change her code while it's running, reducing the cost of mistakes and improving the interactivity of the programming process. I discuss the benefits and limitations of this approach along with the related work.</div>
  <p>For the last year, I’ve been creating a lot of programs for data manipulation (specifically <a href="https://github.com/scanner-research/scanner/">video analysis</a>), and while the heavy lifting is usually in C or Rust, the lighter-weight metadata processing is all Python. As with many in the data science field, I’ve fallen in love with <a href="http://jupyter.org/">Jupyter notebooks</a>, the code editing and output visualization environment. Jupyter’s most-touted feature is the ability to intertwine code, narrative, and visualization. Write code to create a graph and display it inline. Create literate documents with Markdown headers. And this is great! I love the ability to create living documents that change when your data does, like the one below I’ve been developing.</p>

<p><img src="/images/assets/debug-jupyter1.png" alt="" /></p>

<p>However, after using Jupyter for a while, I’ve noticed that it has changed my programming process in a way more fundamental than simply inlining visualization of results. Specifically, <em class="hl">Jupyter enables programmers to edit their program while it is running.</em> Here’s a quick example. Let’s say I have some expensive computation (detect faces in a video) and I want to post-process the results (draw boxes on the faces). Normally, the development process would be, I write a first draft of the program:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## face.py</span>

<span class="c"># Takes 1 minute</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">load_video</span><span class="p">()</span>

<span class="c"># Takes 20 minutes</span>
<span class="n">all_faces</span> <span class="o">=</span> <span class="n">detect_faces</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>

<span class="c"># Takes 1 minute</span>
<span class="k">for</span> <span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame_faces</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">frames</span><span class="p">(),</span> <span class="n">all_faces</span><span class="p">):</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="s">'frame{}.jpg'</span><span class="p">,</span> <span class="n">draw_faces</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame_faces</span><span class="p">))</span>
</code></pre></div></div>

<p>If I run this program (<code class="highlighter-rouge">python face.py</code>), it would probably run to completion, except… oh no! A bug: I forgot to format the <code class="highlighter-rouge">'frame{}.jpg'</code> string (note: not a bug a type system would have found, this isn’t just a dynamic typing issue). But I had to wait 22 minutes to discover this bug, and now when I fix it, I have to re-run my program and wait another 22 minutes to confirm that it works. Why? Even though the bug was in the post-processing, I have to re-run the core computation, since my program exited upon completion, releasing its contents from memory. I should be able to just change the bug, and verify my change in only a minute. How can we do that?</p>

<p>Consider the same workflow, but running in Jupyter. First, I would define a separate code cell to run each part of the pipeline:</p>

<p><img src="/images/assets/debug-jupyter2.png" alt="" /></p>

<p>I would execute each part of the pipeline:</p>

<p><img src="/images/assets/debug-jupyter3.png" alt="" /></p>

<p>Then, after inspecting the output and noticing the error, change the last code cell, and <em>only re-run that cell</em>:</p>

<p><img src="/images/assets/debug-jupyter4.png" alt="" /></p>

<p>This works exactly as intended! We were able to edit our program <em>while it was running</em>, and then re-run only the part that needed fixing. In some sense, this is an obvious result—a REPL is designed to do exactly this, allow you to create new code while inside a long-running programming environment. But <em class="hl">the difference between Jupyter and a REPL is that Jupyter is persistent</em>. Code which I write in a REPL disappears along with my data when the REPL exits, but Jupyter notebooks hang around. Jupyter’s structure of delimited code cells enables a programming style where each can be treated like an atomic unit, where if it completes, then its effects are persisted in memory for other code cells to process.</p>

<p>More generally, we can view this as a form of programming in the debugger. <em class="hl">Rather than separating code creation and code execution as different phases of the programming cycle, they become intertwined.</em> Jupyter performs the many functions of a debugger—inspecting the values of variables, setting breakpoints (ends of code cells), providing rich visualization of program intermediates (e.g. graphs)—except the programmer can react to program’s execution by changing the code while it runs.</p>

<p>However, this style of programming with Jupyter has its limits. For example, <em class="hl">Jupyter penalizes abstraction by removing this interactive debuggability</em>. In the face detection example above, if we made our code generic over the input video:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">detect_and_draw_faces</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>
    <span class="n">all_faces</span> <span class="o">=</span> <span class="n">detect_faces</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame_faces</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">frames</span><span class="p">(),</span> <span class="n">all_faces</span><span class="p">):</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="s">'frame{}.jpg'</span><span class="p">,</span> <span class="n">draw_faces</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame_faces</span><span class="p">))</span>

<span class="n">video</span> <span class="o">=</span> <span class="n">load_video</span><span class="p">()</span>
<span class="n">detect_and_draw_faces</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>
</code></pre></div></div>

<p>Because a single function cannot be split up over multiple code cells, we cannot break the execution of the function in the middle, change its code, and continue to run. Interactive editing and debugging is limited to top-level code. This is actually a really common problem for me, since I’ll write straight-line code for a single instance of the pipeline (on a particular video, as originally), but then want to run it over many videos in batch. However, inevitably I missed some edge case not exposed by the example video, but I can no longer debug the issue in the same way.</p>

<p>Additionally, <em class="hl">this model of debugging/editing only works for code blocks that are pure</em>, i.e. don’t rely on global state outside the block. For example, if I have a program like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c">### new code block ###</span>

<span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="s">'{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</code></pre></div></div>

<p>Then if I fix the variable name error (<code class="highlighter-rouge">format(x)</code> instead of <code class="highlighter-rouge">y</code>) and re-run the code block, the value of <code class="highlighter-rouge">x</code> has changed, and my program output depends on the number of times I debugged the function. Not good! Essentially we need some kind of <a href="http://jakob.engbloms.se/archives/1554">reverse debugging</a> (also time-traveling debugging), where we can rewind the state of the program back to a reasonable point before the error occured. This <a href="https://morepypy.blogspot.com/2016/07/reverse-debugging-for-python.html">has</a> <a href="https://everythingsysadmin.com/2014/04/time-travel-pdb.html">been</a> <a href="http://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/NiklasSteidl.pdf">done</a> for Python, but to my knowledge has never been integrated into Jupyter in a sensible way.</p>

<p>This idea has existed in many other forms, particularly in the web world where hot-swapping code is common. An ideal model is embodied in the <a href="http://elm-lang.org/blog/time-travel-made-easy">Elm Reactor</a> time-traveling debugger for the <a href="http://elm-lang.org/">Elm</a> programming language. If your language is pure and functionally reactive, then you almost get this mode of debugging for free (plus a little tooling). The interesting question, then, is if your language is impure, or if your language <a href="http://willcrichton.net/notes/gradual-programming/">gradually ensured</a> purity, how far can we go with these edit/debug interactions? Could we integrate reverse debugging into Jupyter for Python? Could I edit a function in the middle of its execution? In what scenarios would such a programming style be most useful?</p>

<p>As always, let me know what you think. Either drop me a line at <a href="mailto:wcrichto@cs.stanford.edu">wcrichto@cs.stanford.edu</a> or leave a comment on the <a href="">Hacker News thread</a>.</p>

</div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-16662292-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-16662292-3');
    </script>
  </body>
</html>
