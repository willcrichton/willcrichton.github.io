<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:creator" content="@tonofcrates" />  
  <meta name="author" content="Will Crichton" />
  <meta name="dcterms.date" content="2023-10-20" />
  <meta name="description" content="How to hash, index, profile, multi-thread, and SIMD your way to incredible speeds." />
  <meta property="og:description" content="How to hash, index, profile, multi-thread, and SIMD your way to incredible speeds." />
  <meta property="og:title" content="Analyzing Data 180,000x Faster with Rust" />
  <title>Analyzing Data 180,000x Faster with Rust</title> 
  <style>pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */</style>
  <style>
/*
 * I add this to html files generated with pandoc.
 */

 html {
  font-size: 100%;
  overflow-y: scroll;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}

body {
  color: black;
  font-family: Palatino, 'Palatino Linotype', Georgia, Times, 'Times New Roman', serif;
  font-size: 16px;
  line-height: 1.7;
  padding: 1em;
  margin: auto;
  max-width: 800px;
  background: white;
}

p {
  hyphens: auto;
  overflow-wrap: anywhere;
}

a {
  text-decoration-thickness: 1px;
}

/* 
a {
  color: #0645ad;
}

a:visited {
  color: #0b0080;
}

a:hover {
  color: #06e;
}

a:active {
  color: #faa700;
}

a:focus {
  outline: thin dotted;
} */

p {
  margin: 1em 0;
}

img {
  max-width: 100%;
}

h1, h2, h3, h4, h5, h6 {
  color: #111;
  line-height: 125%;
  margin-top: 2em;
  font-weight: normal;
}

h4, h5, h6 {
  font-weight: bold;
}

h1 {
  font-size: 2.25em;
}

h2 {
  font-size: 1.75em;
}

h3 {
  font-size: 1.3em;
}

h4 {
  font-size: 1.1em;
}

h5 {
  font-size: 1em;
}

h6 {
  font-size: 0.9em;
}

blockquote {
  color: #666666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em #EEE solid;
}

hr {
  display: block;
  height: 2px;
  border: 0;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #eee;
  margin: 1em 0;
  padding: 0;
}

pre, code, kbd, samp {
  color: #000;
  font-family: Inconsolata, monospace;
  /* _font-family: 'courier new', monospace; */
  font-size: 0.98em;
}

/* pre {
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
} */

b, strong {
  font-weight: bold;
}

dfn {
  font-style: italic;
}

ins {
  background: #ff9;
  color: #000;
  text-decoration: none;
}

mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

sub, sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

ul, ol {
  margin: 1em 0;
  padding: 0 0 0 2em;
}

li p:last-child {
  margin-bottom: 0;
}

ul ul, ol ol {
  margin: .3em 0;
}

dl {
  margin-bottom: 1em;
}

dt {
  font-weight: bold;
  margin-bottom: .8em;
}

dd {
  margin: 0 0 .8em 2em;
}

dd:last-child {
  margin-bottom: 0;
}

img {
  border: 0;
  -ms-interpolation-mode: bicubic;
  vertical-align: middle;
}

figure {
  display: block;
  text-align: center;
  margin-left: 0;
  margin-right: 0;
}

figure img {
  border: none;
  margin: 0 auto;
}

figcaption {  
  margin: 0 0 .8em;
}

table {
  margin-top: 2em;
  margin-bottom: 3em;
  border-bottom: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-spacing: 0;
  border-collapse: collapse;
}

table th {
  padding: .2em 1em;
  background-color: #eee;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
}

table td {
  padding: .2em 1em;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
  vertical-align: top;
}

.author {
  font-size: 1.2em;
  text-align: center;
  font-style: italic;
}

.date {
  margin-left: 2em;
}

#refs {
  margin-top: 4em;
}

@media only screen and (min-width: 480px) {
  body {
    font-size: 16px;
  }
}
@media only screen and (min-width: 768px) {
  body {
    font-size: 18px;
  }

  p {
    text-align: justify;
  }
}

@media only screen and (max-width: 768px) {
  h1 {
    margin-top: 0;
  }

  ul, ol {
    padding-left: 1em;
  }
}

@media only screen and (min-width: 1200px) {
  .hero {
    width: 1200px;
    max-width: none;
    position: relative;
    right: 200px;
  }

  figure {
    margin: 2em 3em;
  }
}
@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter: none !important;
    -ms-filter: none !important;
  }

  body {
    font-size: 12pt;
    max-width: 100%;
  }

  a, a:visited {
    text-decoration: underline;
  }

  hr {
    height: 1px;
    border: 0;
    border-bottom: 1px solid black;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
    content: "";
  }

  pre, blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  tr, img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  @page :left {
    margin: 15mm 20mm 15mm 10mm;
}

  @page :right {
    margin: 15mm 10mm 15mm 20mm;
}

  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }

  h2, h3 {
    page-break-after: avoid;
  }
}

.hero {
  margin: 0.5em 0 2em;
}

div.sourceCode, pre {
  background: #fafafa;
  padding: 0.25em 0.5em;
  overflow-x: auto;
}

p code, li code {
  background: #f5f5f5;
  padding: 1px 2px;
}

figure, body > div {
  max-width: 100%;
  overflow-x: auto;
}

.center {
  display: block;
  margin: 0 auto;
}

  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Analyzing Data 180,000x Faster with Rust</h1>
<span class="author">Will Crichton</span>
<span class="date">October 20, 2023</span>
</header>
<p>This note documents one of my recent adventures in performance
optimization with Rust. By following along, hopefully you’ll learn
something about how to write fast Rust.</p>
<p>Here’s the context: imagine you have data from an online exam where a
set of users answered a set of questions. The raw data looks like
this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;user&quot;</span><span class="op">:</span> <span class="st">&quot;5ea2c2e3-4dc8-4a5a-93ec-18d3d9197374&quot;</span><span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;question&quot;</span><span class="op">:</span> <span class="st">&quot;7d42b17d-77ff-4e0a-9a4d-354ddd7bbc57&quot;</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;score&quot;</span><span class="op">:</span> <span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;user&quot;</span><span class="op">:</span> <span class="st">&quot;b7746016-fdbf-4f8a-9f84-05fde7b9c07a&quot;</span><span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;question&quot;</span><span class="op">:</span> <span class="st">&quot;7d42b17d-77ff-4e0a-9a4d-354ddd7bbc57&quot;</span><span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;score&quot;</span><span class="op">:</span> <span class="dv">0</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span>  </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* ... more data ... */</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>Note that each user only answered a subset of all possible questions,
and all scores are either 0 or 1.</p>
<p>Here’s the problem: given a size
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>,
which set of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>
questions has the highest correlation with overall performance? We’ll
call this the <strong>k-CorrSet problem</strong>. A simple brute-force
algorithm for solving the k-CorrSet problem looks like this
pseudocode:</p>
<pre><code>func k_corrset($data, $k):
  $all_qs = all questions in $data
  for all $k-sized subsets $qs within $all_qs:
    $us = all users that answered every question in $qs
    $qs_totals = the total score on $qs of each user in $us
    $grand_totals = the grand score on $all_qs of each user in $us
    $r = correlation($qs_totals, $grand_totals)
  return $qs with maximum $r    </code></pre>
<p>We are going to implement several variations on this algorithm to see
how fast we can make it.</p>
<h2 id="python-baseline">Python Baseline</h2>
<p>When I do data analysis, I usually start with Python and then
transition to Rust when I need better speed or memory consumption. So as
a baseline, let’s look at a straightforward <a
href="https://pandas.pydata.org/">Pandas</a> program for solving
k-CorrSet:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pandas <span class="im">import</span> IndexSlice <span class="im">as</span> islice</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> k_corrset(data, K):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    all_qs <span class="op">=</span> data.question.unique()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    q_to_score <span class="op">=</span> data.set_index([<span class="st">&#39;question&#39;</span>, <span class="st">&#39;user&#39;</span>])</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    all_grand_totals <span class="op">=</span> data.groupby(<span class="st">&#39;user&#39;</span>).score.<span class="bu">sum</span>().rename(<span class="st">&#39;grand_total&#39;</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    corrs <span class="op">=</span> []</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> qs <span class="kw">in</span> combinations(all_qs, K):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        qs_data <span class="op">=</span> q_to_score.loc[islice[qs,:],:].swaplevel()</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        answered_all <span class="op">=</span> qs_data.groupby(level<span class="op">=</span>[<span class="dv">0</span>]).size() <span class="op">==</span> K</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        answered_all <span class="op">=</span> answered_all[answered_all].index</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        qs_totals <span class="op">=</span> qs_data.loc[islice[answered_all,:]] <span class="op">\</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            .groupby(level<span class="op">=</span>[<span class="dv">0</span>]).<span class="bu">sum</span>().rename(columns<span class="op">=</span>{<span class="st">&#39;score&#39;</span>: <span class="st">&#39;qs&#39;</span>})</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> qs_totals.join(all_grand_totals).corr().qs.grand_total</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        corrs.append({<span class="st">&#39;qs&#39;</span>: qs, <span class="st">&#39;r&#39;</span>: r})</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    corrs <span class="op">=</span> pd.DataFrame(corrs)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> corrs.sort_values(<span class="st">&#39;r&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).iloc[<span class="dv">0</span>].qs</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_json(<span class="st">&#39;scores.json&#39;</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(k_corrset(data, K<span class="op">=</span><span class="dv">5</span>))</span></code></pre></div>
<p>This uses a bit of <a
href="https://pandas.pydata.org/docs/user_guide/advanced.html">MultiIndex</a>
magic, but don’t sweat the details. Let’s start benchmarking. First, we
need data. To make the benchmark realistic, I generated synthetic data
that roughly matches the properties of my actual data. The properties of
the synthetic data are:</p>
<ul>
<li>60,000 users</li>
<li>200 questions</li>
<li>20% sparsity (i.e., 12,000 users answered each question)</li>
<li>Each score is equally likely 1 or 0</li>
</ul>
<p>Our goal will be to compute k-CorrSet on this dataset for k = 5 in a
reasonable amount of time on my 2021 M1 Macbook Pro. Note that there are
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mn>200</mn><mn>5</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{200}{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2451em;vertical-align:-0.35em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8951em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">200</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span>
= 2.5 billion combinations of questions, so we need the inner loop of
the brute-force algorithm to be quite fast.</p>
<p>Using Python’s <a
href="https://docs.python.org/3/library/time.html#time.time"><code>time.time()</code></a>
function, I computed the speed of the inner loop for 1,000 iterations
running with CPython 3.9.17. The average execution time was <strong>36
milliseconds</strong>. Not too bad, but at this rate, the full
computation would complete in <strong>2.9 years</strong>. Let’s make
that faster!</p>
<blockquote>
<p>Note: there are lots of ways we could make the Python code faster,
but the point of this post isn’t to compare highly-optimized Python to
highly-optimized Rust. The point is to compare
“standard-Jupyter-notebook” Python to highly-optimized Rust.</p>
</blockquote>
<h2 id="rust-reimplementation">Rust Reimplementation</h2>
<p>We can start optimizing by reimplementing the Python code into a
roughly equivalent Rust program, expecting some free speedups from
Rust’s compiler optimizations. For readability, all the code below is a
simplification of the actual benchmark. For instance, I will omit
<code>#[derive]</code>s on types, and I will coalesce disparate blocks
of code into straight-line functions. You can see the full benchmark
here: <a href="https://github.com/willcrichton/corrset-benchmark"
class="uri">https://github.com/willcrichton/corrset-benchmark</a></p>
<p>First, we translate the data types:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> User(<span class="kw">pub</span> <span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Question(<span class="kw">pub</span> <span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Row <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> user<span class="op">:</span> User<span class="op">,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> question<span class="op">:</span> Question<span class="op">,</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> score<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We make <code>User</code> and <code>Question</code> into newtypes
both for clarity and so we can implement traits on them. Then, the basic
k-CorrSet algorithm is implemented as follows:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> k_corrset(data<span class="op">:</span> <span class="op">&amp;</span>[Row]<span class="op">,</span> k<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;&amp;</span>Question<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// utils::group_by(impl Iterator&lt;Item = (K1, K2, V)&gt;) </span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   -&gt; HashMap&lt;K1, HashMap&lt;K2, V&gt;&gt;;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> q_to_score<span class="op">:</span> HashMap<span class="op">&lt;&amp;</span>Question<span class="op">,</span> HashMap<span class="op">&lt;&amp;</span>User<span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">utils::</span>group_by(data<span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>r<span class="op">|</span> (<span class="op">&amp;</span>r<span class="op">.</span>question<span class="op">,</span> <span class="op">&amp;</span>r<span class="op">.</span>user<span class="op">,</span> r<span class="op">.</span>score)))<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> u_to_score<span class="op">:</span> HashMap<span class="op">&lt;&amp;</span>User<span class="op">,</span> HashMap<span class="op">&lt;&amp;</span>Question<span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">utils::</span>group_by(data<span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>r<span class="op">|</span> (<span class="op">&amp;</span>r<span class="op">.</span>user<span class="op">,</span> <span class="op">&amp;</span>r<span class="op">.</span>question<span class="op">,</span> r<span class="op">.</span>score)))<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> all_grand_totals<span class="op">:</span> HashMap<span class="op">&lt;&amp;</span>User<span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;</span> <span class="op">=</span> </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    u_to_score<span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>(user<span class="op">,</span> scores)<span class="op">|</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> total <span class="op">=</span> scores<span class="op">.</span>values()<span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>      (<span class="op">*</span>user<span class="op">,</span> total)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> all_qs <span class="op">=</span> q_to_score<span class="op">.</span>keys()<span class="op">.</span>copied()<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  all_qs<span class="op">.</span>combinations(k)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>filter_map(<span class="op">|</span>qs<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;&amp;</span>Question<span class="op">&gt;|</span> <span class="op">{</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> (qs_totals<span class="op">,</span> grand_totals)<span class="op">:</span> (<span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;,</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span>) <span class="op">=</span> all_grand_totals<span class="op">.</span>iter()</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>filter_map(<span class="op">|</span>(u<span class="op">,</span> grand_total)<span class="op">|</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> q_total <span class="op">=</span> qs<span class="op">.</span>iter()</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>map(<span class="op">|</span>q<span class="op">|</span> q_to_score[<span class="op">*</span>q]<span class="op">.</span>get(u)<span class="op">.</span>copied())</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">Option</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;&gt;</span>()<span class="op">?;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>          <span class="cn">Some</span>((q_total <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> <span class="op">*</span>grand_total <span class="kw">as</span> <span class="dt">f64</span>))</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>unzip()<span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>      <span class="co">// utils::correlation(&amp;[f64], &amp;[f64]) -&gt; f64;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> r <span class="op">=</span> <span class="pp">utils::</span>correlation(<span class="op">&amp;</span>qs_totals<span class="op">,</span> <span class="op">&amp;</span>grand_totals)<span class="op">;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>      (<span class="op">!</span>r<span class="op">.</span>is_nan())<span class="op">.</span>then_some((qs<span class="op">,</span> r))</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>max_by_key(<span class="op">|</span>(_<span class="op">,</span> r)<span class="op">|</span> FloatOrd(<span class="op">*</span>r))</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">.</span><span class="dv">0</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The key elements to understand:</p>
<ul>
<li>Like with Python, we convert the flat data into hierarchical data
with a hashmap and the <code>utils::group_by</code> helper. (Note that
everywhere we refer to <code>HashMap</code> is actually an alias for <a
href="https://docs.rs/fxhash/0.2.1/fxhash/type.FxHashMap.html"><code>fxhash::FxHashMap</code></a>,
which is just <a
href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>std::collections::HashMap</code></a>
with a more efficient hashing algorithm.)</li>
<li>Then we iterate over all combinations of questions using the <a
href="https://docs.rs/itertools/0.11.0/itertools/trait.Itertools.html#method.combinations"><code>Itertools::combinations</code></a>
method.</li>
<li>In the inner loop, we iterate over all users via
<code>all_grand_totals.iter()</code>.</li>
<li>The expression <code>q_to_score[*q].get(u).copied()</code> has type
<code>Option&lt;u32&gt;</code>, which is <code>Some(n)</code> if the
user has a score for <code>q</code>, and <code>None</code>
otherwise.</li>
<li>The iterator method <code>.sum::&lt;Option&lt;u32&gt;&gt;()</code>
returns <code>Some(total)</code> if the user answered every question in
<code>qs</code>, and <code>None</code> otherwise.</li>
<li>We call a helper method <code>utils::correlation</code> that
implements a standard calculation for <a
href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson’s
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></a>.</li>
<li>We use <code>max_by_key</code> to get the questions with the highest
correlation. We use <a
href="https://docs.rs/float-ord/0.3.2/float_ord/struct.FloatOrd.html"><code>FloatOrd</code></a>
so we can compare floats.</li>
</ul>
<p>So how’s the performance? I used <a
href="https://bheisler.github.io/criterion.rs/book/index.html">Criterion</a>
to benchmark the performance of the inner loop (the
<code>filter_map</code>) with Criterion’s default settings, using the
same dataset as before. The new inner loop runs in <strong>4.2
milliseconds</strong>, which is about 8 times faster than the Python
baseline! But our full computation is still 124 days, which is too long.
Now let’s start really optimizing.</p>
<h2 id="indexed-data">Indexed Data</h2>
<p>Rather than guess how to optimize the code, let’s run a profiler to
see where the bottleneck is. On my Mac, I usually use <a
href="https://en.wikipedia.org/wiki/Instruments_(software)">Instruments.app</a>,
but recently I tried <a
href="https://github.com/mstange/samply/">samply</a> and wow! It’s much
nicer to use. Samply seems to work better with Rust both in terms of
symbol demangling and in terms of reconstructing the call stack. Here’s
a screenshot of the relevant part of the samply trace for the Rust
implementation so far:</p>
<p><img src="img/profile-naive.png" /></p>
<p>We’re spending 75% of our time in <code>HashMap::get</code>! This is
the offending line of code:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>q_to_score[<span class="op">*</span>q]<span class="op">.</span>get(u)<span class="op">.</span>copied()</span></code></pre></div>
<p>The problem is that we’re hashing and comparing 36-byte UUID strings,
which is expensive. We need a smaller type that can stand-in for the
question/user strings.</p>
<p>The solution is that we will collect all the questions and users into
a <code>Vec</code>, and represent each question/user by their index in
that <code>Vec</code>. We could just use <code>usize</code> indices with
the <code>Vec</code> type, but a better practice is to use newtypes to
represent each kind of index. In fact, this problem comes up so often in
my work that I’ve already made a crate for it, <a
href="https://docs.rs/indexical/0.6.0/indexical/index.html">Indexical</a>
(which builds on the <a
href="https://docs.rs/index_vec/0.1.3/index_vec/index.html">index_vec</a>
crate). We define those index types like this:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> QuestionRef<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(<span class="kw">pub</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> Question)<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> UserRef<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(<span class="kw">pub</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> User)<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="pp">define_index_type!</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">struct</span> QuestionIdx <span class="cf">for</span> QuestionRef<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">u16</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="pp">define_index_type!</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">struct</span> UserIdx <span class="cf">for</span> UserRef<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>QuestionRef</code> and <code>UserRef</code> types are
newtypes that enable us to implement traits on
<code>&amp;Question</code> and <code>&amp;User</code>. The
<code>define_index_type</code> macro creates new index types
<code>QuestionIdx</code> and <code>UserIdx</code> which are associated
with <code>QuestionRef</code> and <code>UserRef</code>. Those indices
are represented as <code>u16</code> and a <code>u32</code>,
respectively.</p>
<p>Finally we update <code>k_corrset</code> to generate an <a
href="https://docs.rs/indexical/0.6.0/indexical/struct.IndexedDomain.html"><code>IndexedDomain</code></a>
for questions and users, and then use the <code>QuestionIdx</code> and
<code>UserIdx</code> types throughout the rest of the code:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> k_corrset(data<span class="op">:</span> <span class="op">&amp;</span>[Row]<span class="op">,</span> k<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;&amp;</span>Question<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// first, we create an `IndexedDomain` for questions and users</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (questions_set<span class="op">,</span> users_set)<span class="op">:</span> (HashSet<span class="op">&lt;</span>_<span class="op">&gt;,</span> HashSet<span class="op">&lt;</span>_<span class="op">&gt;</span>) <span class="op">=</span> data<span class="op">.</span>iter()</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>map(<span class="op">|</span>row<span class="op">|</span> (QuestionRef(<span class="op">&amp;</span>row<span class="op">.</span>question)<span class="op">,</span> UserRef(<span class="op">&amp;</span>row<span class="op">.</span>user)))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unzip()<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> questions <span class="op">=</span> <span class="pp">IndexedDomain::</span>from_iter(questions_set)<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> users <span class="op">=</span> <span class="pp">IndexedDomain::</span>from_iter(users_set)<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// then we create the same data structures as before, </span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// except using `IndexedDomain::index` to lookup indices.</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// note the change in the HashMap key types</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> q_to_score<span class="op">:</span> HashMap<span class="op">&lt;</span>QuestionIdx<span class="op">,</span> HashMap<span class="op">&lt;</span>UserIdx<span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> </span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">utils::</span>group_by(data<span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>r<span class="op">|</span> (</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>      questions<span class="op">.</span>index(<span class="op">&amp;</span>(QuestionRef(<span class="op">&amp;</span>r<span class="op">.</span>question)))<span class="op">,</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      users<span class="op">.</span>index(<span class="op">&amp;</span>(UserRef(<span class="op">&amp;</span>r<span class="op">.</span>user)))<span class="op">,</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      r<span class="op">.</span>score<span class="op">,</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    )))<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> u_to_score<span class="op">:</span> HashMap<span class="op">&lt;</span>UserIdx<span class="op">,</span> HashMap<span class="op">&lt;</span>QuestionIdx<span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> </span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">utils::</span>group_by(data<span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>r<span class="op">|</span> (</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>      users<span class="op">.</span>index(<span class="op">&amp;</span>(UserRef(<span class="op">&amp;</span>r<span class="op">.</span>user)))<span class="op">,</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>      questions<span class="op">.</span>index(<span class="op">&amp;</span>(QuestionRef(<span class="op">&amp;</span>r<span class="op">.</span>question)))<span class="op">,</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>      r<span class="op">.</span>score<span class="op">,</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    )))<span class="op">;</span>  </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> all_grand_totals <span class="op">=</span> <span class="co">// same code</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> all_qs <span class="op">=</span> questions<span class="op">.</span>indices()<span class="op">;</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>  all_qs<span class="op">.</span>combinations(k)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>filter_map(<span class="op">|</span>qs<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>QuestionIdx<span class="op">&gt;|</span> <span class="op">{</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>      <span class="co">// same code</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>max_by_key(<span class="op">|</span>(_<span class="op">,</span> r)<span class="op">|</span> FloatOrd(<span class="op">*</span>r))</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">.</span><span class="dv">0</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we have to post-process the indices back to values</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>into_iter()<span class="op">.</span>map(<span class="op">|</span>idx<span class="op">|</span> questions<span class="op">.</span>value(idx)<span class="op">.</span><span class="dv">0</span>)<span class="op">.</span>collect()</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Again, check out the <a
href="https://github.com/willcrichton/corrset-benchmark/blob/main/src/inner/indexed.rs">GitHub</a>
for the complete implementation, and check out the <a
href="https://docs.rs/indexical/0.6.0/indexical/index.html">indexical
docs</a> for details on its API.</p>
<p>Once again we run our benchmark on the inner loop of the computation.
The new inner loop runs in <strong>1.0 milliseconds</strong>, which is 4
times faster than our last iteration, and 35 times faster than our
Python baseline. We’re down to 30 days for the total computation — let’s
keep going!</p>
<h2 id="indexed-collections">Indexed Collections</h2>
<p>Let’s profile again:</p>
<p><img src="img/profile-indexed.png" /></p>
<p>Blast, still spending most our time in <code>HashMap::get</code>.
Well, what if we got rid of hash maps altogether? A
<code>HashMap&lt;&amp;User, u32&gt;</code> is conceptually the same
thing as a <code>Vec&lt;Option&lt;u32&gt;&gt;</code> where each
<code>&amp;User</code> has a unique index. For example, in a domain of
users <code>["a", "b", "c"]</code>, then the hash map
<code>{"b" =&gt; 1}</code> is equivalent to the vector
<code>[None, Some(1), None]</code>. This vector costs more memory
(paying for the <code>None</code> spaces), but it improves the
performance of key/value lookups (avoids hashing).</p>
<p>We’re trying to fully optimize for performance, and given the scale
of our dataset, we can afford to make the compute/memory trade-off. We
will use Indexical which provides a <a
href="https://docs.rs/indexical/0.6.0/indexical/map/struct.DenseIndexMap.html"><code>DenseIndexMap&lt;K, V&gt;</code></a>
type that is internally implemented as a <code>Vec&lt;V&gt;</code> type
indexed by <code>K::Index</code>.</p>
<p>The main change to the <code>k_corrset</code> function is that we
convert all our auxiliary data structures to dense index maps:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">type</span> QuestionMap<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">=</span> DenseIndexMap<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> QuestionRef<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;,</span> T<span class="op">&gt;;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">type</span> UserMap<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">=</span> DenseIndexMap<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> UserRef<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;,</span> T<span class="op">&gt;;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> k_corrset(data<span class="op">:</span> <span class="op">&amp;</span>[Row]<span class="op">,</span> k<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;&amp;</span>Question<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// build the `users` and `questions` domains same as before</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Initialize q_to_score to an empty dense map</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> q_to_score<span class="op">:</span> QuestionMap<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> UserMap<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;&gt;&gt;</span> <span class="op">=</span> </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">QuestionMap::</span>new(<span class="op">&amp;</span>questions<span class="op">,</span> <span class="op">|</span>_<span class="op">|</span> <span class="pp">UserMap::</span>new(<span class="op">&amp;</span>users<span class="op">,</span> <span class="op">|</span>_<span class="op">|</span> <span class="cn">None</span>))<span class="op">;</span>  </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Fill in q_to_score with the dataset</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> r <span class="kw">in</span> data <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    q_to_score</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>get_mut(<span class="op">&amp;</span>QuestionRef(<span class="op">&amp;</span>r<span class="op">.</span>question))</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>unwrap()</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>insert(UserRef(<span class="op">&amp;</span>r<span class="op">.</span>user)<span class="op">,</span> <span class="cn">Some</span>(r<span class="op">.</span>score))<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> grand_totals <span class="op">=</span> <span class="pp">UserMap::</span>new(<span class="op">&amp;</span>users<span class="op">,</span> <span class="op">|</span>u<span class="op">|</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    q_to_score<span class="op">.</span>values()<span class="op">.</span>filter_map(<span class="op">|</span>v<span class="op">|</span> v[u])<span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;</span>()</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> all_qs <span class="op">=</span> questions<span class="op">.</span>indices()<span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>  all_qs<span class="op">.</span>combinations(k)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// almost the same code, see below</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The only change to the inner loop is that our code which used to say
this:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>q_to_score[<span class="op">*</span>q]<span class="op">.</span>get(u)<span class="op">.</span>copied()</span></code></pre></div>
<p>Is now this:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>q_to_score[<span class="op">*</span>q][u]</span></code></pre></div>
<p>Running the benchmark again, the new inner loop runs in <strong>181
microseconds</strong>, which is 6 times faster than our last iteration,
and 199 times faster than our Python baseline. We’re down to 5.3 days
for the total computation.</p>
<h2 id="bounds-checks">Bounds Checks</h2>
<p>Another small performance hit comes every time we use the brackets
<code>[]</code> to index into an <code>DenseIndexMap</code>. The vector
beneath will run a bounds-check for safety, but our code is guaranteed
to never exceed vector bounds as written. I couldn’t actually find the
bounds check in the samply profile, but it does make a noticeable
difference in the benchmark, so it’s worth implementing.</p>
<p>Before our inner loop looked like this:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> q_total <span class="op">=</span> qs<span class="op">.</span>iter()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>map(<span class="op">|</span>q<span class="op">|</span> q_to_score[<span class="op">*</span>q][u])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">Option</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;&gt;</span>()<span class="op">?;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> grand_total <span class="op">=</span> all_grand_totals[u]<span class="op">;</span></span></code></pre></div>
<p>Removing bounds checks with <code>get_unchecked</code>, our new inner
loop looks like this:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> q_total <span class="op">=</span> qs<span class="op">.</span>iter()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>map(<span class="op">|</span>q<span class="op">|</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> u_scores <span class="op">=</span> q_to_score<span class="op">.</span>get_unchecked(q)<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>u_scores<span class="op">.</span>get_unchecked(u)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">Option</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;&gt;</span>()<span class="op">?;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> grand_total <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">*</span>all_grand_totals<span class="op">.</span>get_unchecked(u) <span class="op">};</span></span></code></pre></div>
<p>It is unsafe without bounds-checks, so we have to mark these blocks
as <code>unsafe</code>.</p>
<p>Running the benchmark again, the new inner loop runs in <strong>156
microseconds</strong>, which is 1.16x faster than our last iteration,
and 229 times faster than our Python baseline. We’re down to 4.6 days
for the total computation.</p>
<h2 id="bit-sets">Bit-sets</h2>
<p>We’re currently at a 225x speedup, which means we still have three
orders of magnitude left to go. To get there, we need to rethink the
computational structure of the inner loop. Right now, our loop
effectively looks like:</p>
<pre class="text"><code>for each subset of questions $qs:
  for each user $u:
    for each question $q in $qs:
      if $u answered $q: add $u&#39;s score on $q to a running total
      else: skip to the next user
    $r = correlation($u&#39;s totals on $qs, $u&#39;s grand total)</code></pre>
<p>An important aspect of our data is that it forms a <em>sparse</em>
matrix. For a given question, only 20% of users have answered that
question. For a set of 5 questions, a much smaller fraction have
answered all 5 questions. So if we can efficiently determine first which
users have answered all 5 questions, then our subsequent loop will run
for fewer iterations (and be free of branches). Something like this:</p>
<pre class="text"><code>for each subset of questions $qs:
  $qs_u = all users who have answered every question in $qs
  for each user $u in $qs_u:
    for each question $q in $qs:
      add $u&#39;s score on $q to a running total
    $r = correlation($u&#39;s scores on $qs, $u&#39;s grand total)</code></pre>
<p>So how do we represent the set of users who have answered a given
question? We could use a <a
href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>HashSet</code></a>,
but we saw earlier that hashing is computationally expensive. Because
our data is indexed, we can use a more efficient data structure: the <a
href="https://en.wikipedia.org/wiki/Bit_array">bit-set</a>, which uses
the individual bits of memory to represent whether an object is present
or absent in a set. Indexical provides another abstraction for
integratings bit-sets with our newtype indices: the <a
href="https://docs.rs/indexical/0.6.0/indexical/struct.IndexSet.html"><code>IndexSet</code></a>.</p>
<p>Previously, our <code>q_to_score</code> data structure mapped from
questions to a user-indexed vector of optional scores (that is,
<code>UserMap&lt;'_, Option&lt;u32&gt;&gt;</code>). Now we will change
<code>Option&lt;u32&gt;</code> to <code>u32</code> and add a bit-set
describing the set of users who answered a given question. The first
half of the updated code looks like this:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> UserSet<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> IndexSet<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> UserRef<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;&gt;;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> q_to_score<span class="op">:</span> QuestionMap<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> (UserSet<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">&gt;,</span> UserMap<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;</span>)<span class="op">&gt;</span> <span class="op">=</span> </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="pp">QuestionMap::</span>new(<span class="op">&amp;</span>questions<span class="op">,</span> <span class="op">|</span>_<span class="op">|</span> (</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">UserMap::</span><span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;</span><span class="pp">::</span>new(<span class="op">&amp;</span>users<span class="op">,</span> <span class="op">|</span>_<span class="op">|</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">UserSet::</span>new(<span class="op">&amp;</span>users)<span class="op">,</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  ))<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> r <span class="kw">in</span> data <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (scores<span class="op">,</span> set) <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> q_to_score<span class="op">.</span>get_mut(<span class="op">&amp;</span>QuestionRef(<span class="op">&amp;</span>r<span class="op">.</span>question))<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  scores<span class="op">.</span>insert(UserRef(<span class="op">&amp;</span>r<span class="op">.</span>user)<span class="op">,</span> r<span class="op">.</span>score)<span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  set<span class="op">.</span>insert(UserRef(<span class="op">&amp;</span>r<span class="op">.</span>user))<span class="op">;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that <code>q_to_score</code> now effectively has invalid values,
since we provide a default value of 0 for users who did not answer a
question. We have to be careful not to use these invalid values in the
computation.</p>
<p>Then we update our inner loop to match the new pseudocode:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> all_qs <span class="op">=</span> questions<span class="op">.</span>indices()<span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>all_qs<span class="op">.</span>combinations(k)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>filter_map(<span class="op">|</span>qs<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>QuestionIdx<span class="op">&gt;|</span> <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute the intersection of the user-sets for each question</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> users <span class="op">=</span> q_to_score[qs[<span class="dv">0</span>]]<span class="op">.</span><span class="dv">1</span><span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> q <span class="kw">in</span> <span class="op">&amp;</span>qs[<span class="dv">1</span><span class="op">..</span>] <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>      users<span class="op">.</span>intersect(<span class="op">&amp;</span>q_to_score[<span class="op">*</span>q]<span class="op">.</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (qs_totals<span class="op">,</span> grand_totals)<span class="op">:</span> (<span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;,</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span>) <span class="op">=</span> users<span class="op">.</span>indices()</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// only .map, not .filter_map as before</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>map(<span class="op">|</span>u<span class="op">|</span> <span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> q_total <span class="op">=</span> qs<span class="op">.</span>iter()          </span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span>map(<span class="op">|</span>q<span class="op">|</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (u_scores<span class="op">,</span> _) <span class="op">=</span> q_to_score<span class="op">.</span>get_unchecked(q)<span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>u_scores<span class="op">.</span>get_unchecked(u)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span>)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>          <span class="co">// only u32, not Option&lt;u32&gt; as before</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> grand_total <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">*</span>all_grand_totals<span class="op">.</span>get_unchecked(u) <span class="op">};</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        (q_total <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> grand_total <span class="kw">as</span> <span class="dt">f64</span>)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span>)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>unzip()<span class="op">;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r <span class="op">=</span> <span class="pp">utils::</span>correlation(<span class="op">&amp;</span>qs_totals<span class="op">,</span> <span class="op">&amp;</span>grand_totals)<span class="op">;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    (<span class="op">!</span>r<span class="op">.</span>is_nan())<span class="op">.</span>then_some((qs<span class="op">,</span> r))</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>)</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// rest of the code is the same</span></span></code></pre></div>
<p>Running the benchmark again, the new inner loop runs in <strong>47
microseconds</strong>, which is 3.4 times faster than our last
iteration, and 769 times faster than our Python baseline. We’re down to
1.4 days for the total computation.</p>
<h2 id="simd">SIMD</h2>
<p>Our new computational structure is definitely helping, but it’s still
not fast enough. Let’s check back in with samply:</p>
<p><img src="img/profile-bitset.png" /></p>
<p>Now we’re spending all our time in the bit-set intersection! That
means we need to dig in to how the bit-set is implemented. The default
bit-set library used by Indexical is <a
href="https://docs.rs/bitvec/1.0.1/bitvec/index.html">bitvec</a>. As of
2023, the implementation of intersection within bitvec’s bit-set is
roughly this code:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> intersect(dst<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> BitSet<span class="op">,</span> src<span class="op">:</span> <span class="op">&amp;</span>BitSet) <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n1<span class="op">,</span> n2)<span class="op">:</span> (<span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">u64</span><span class="op">,</span> <span class="op">&amp;</span><span class="dt">u64</span>) <span class="kw">in</span> dst<span class="op">.</span>iter_mut()<span class="op">.</span>zip(<span class="op">&amp;</span>src) <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>n1 <span class="op">&amp;=</span> <span class="op">*</span>n2<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So bitvec is AND-ing a <code>u64</code> at a time. But it turns out
most processors have instructions specifically for doing
bit-manipulation on multiple <code>u64</code>s at a time, called <a
href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a>
(single instruction, multiple data). Thankfully, Rust provides an
experimental SIMD API <a
href="https://doc.rust-lang.org/std/simd/index.html"><code>std::simd</code></a>
that we can use. Roughly speaking, the SIMD version of bit-set
intersection looks like this:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> intersect(dst<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> SimdBitSet<span class="op">,</span> src<span class="op">:</span> <span class="op">&amp;</span>SimdBitSet) <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n1<span class="op">,</span> n2)<span class="op">:</span> (<span class="op">&amp;</span><span class="kw">mut</span> u64x4<span class="op">,</span> <span class="op">&amp;</span>u64x4) <span class="kw">in</span> dst<span class="op">.</span>iter_mut()<span class="op">.</span>zip(<span class="op">&amp;</span>src) <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>n1 <span class="op">&amp;=</span> <span class="op">*</span>n2<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The only difference is that we’ve replaced our primitive
<code>u64</code> type with a SIMD type <a
href="https://doc.rust-lang.org/std/simd/type.u64x4.html"><code>u64x4</code></a>,
and under the hood, Rust emits a single SIMD instruction to perform the
<code>&amp;=</code> operation that ANDs four <code>u64</code>s at a
time.</p>
<p>Where can we find a SIMD-accelerated bitset? <a
href="https://docs.rs/bitvec/1.0.1/bitvec/index.html">bitvec</a> doesn’t
support SIMD. There are a few on <a
href="https://crates.io">crates.io</a>, and I tried out one called <a
href="https://github.com/psiace/bitsvec">bitsvec</a>. It works well for
fast intersection, but I found that its iterator which finds the indices
of the 1-bits is actually quite slow. So I copied large portions of the
bitsvec implementation and wrote a more efficient iterator, which you
can check out in the <a
href="https://github.com/willcrichton/indexical/blob/913fbf5830f4d5acedd23e04841e453ed2659165/src/bitset/simd.rs">Indexical
source</a> if you’re curious.</p>
<p>Thanks to Indexical’s abstractions, swapping in the SIMD bitset only
requires changing a type alias and no other modifications to the
<code>k_corrset</code> function. I experimented with different lane
sizes and found <code>u64x16</code> is the most efficient on my machine
for this dataset.</p>
<p>Once more we run the benchmark, and the new inner loop runs in
<strong>1.35 microseconds</strong>, which is 34 times faster than our
last iteration, and 26,459 times faster than our Python baseline. We’re
down to 57 minutes for the total computation.</p>
<h2 id="allocation">Allocation</h2>
<p>At this point, we’re pretty close to peak performance. (You may not
like it, but…) Let’s go back to the profile, this time looking at the
inverted view (which shows the most-called functions at the leaves of
the call tree):</p>
<p><img src="img/profile-simd.png" /></p>
<p>The biggest bottleneck is our bit-set iterator! I wasn’t joking! But
we see several concerning functions: <code>memmove</code>,
<code>realloc</code>, <code>allocate</code> — that’s right, we’re
allocating memory in the inner loop of this function. Specifically,
there’s the user bit-set that we initially clone, and there’s the two
vectors for <code>qs_totals</code> and <code>grand_totals</code> that we
allocate with <code>unzip</code>.</p>
<p>To avoid allocation, we create these data structures up front with
the maximum possible size needed, and then repeatedly write into
them:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate our data up front</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> qs_totals <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">.;</span> users<span class="op">.</span>len()]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> grand_totals <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">.;</span> users<span class="op">.</span>len()]<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> user_set <span class="op">=</span> <span class="pp">IndexSet::</span>new(<span class="op">&amp;</span>users)<span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> all_qs <span class="op">=</span> questions<span class="op">.</span>indices()<span class="op">;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>all_qs<span class="op">.</span>combinations(k)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>filter_map(<span class="op">|</span>qs<span class="op">|</span> <span class="op">{</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Use `clone_from` rather than `clone` to copy without allocation</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    user_set<span class="op">.</span>clone_from(<span class="op">&amp;</span>q_to_score[qs[<span class="dv">0</span>]]<span class="op">.</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> q <span class="kw">in</span> <span class="op">&amp;</span>qs[<span class="dv">1</span><span class="op">..</span>] <span class="op">{</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>      user_set<span class="op">.</span>intersect(<span class="op">&amp;</span>q_to_score[<span class="op">*</span>q]<span class="op">.</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i<span class="op">,</span> u) <span class="kw">in</span> user_set<span class="op">.</span>indices()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> q_total <span class="op">=</span> qs<span class="op">.</span>iter()</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>q<span class="op">|</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> (u_scores<span class="op">,</span> _) <span class="op">=</span> q_to_score<span class="op">.</span>get_unchecked(q)<span class="op">;</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>          <span class="op">*</span>u_scores<span class="op">..</span>get_unchecked(u)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> grand_total <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">*</span>all_grand_totals<span class="op">.</span>get_unchecked(u) <span class="op">};</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Update totals/grand_totals in-place rather than pushing into a vector</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>qs_totals<span class="op">.</span>get_unchecked_mut(i) <span class="op">=</span> q_total <span class="kw">as</span> <span class="dt">f64</span><span class="op">;</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>grand_totals<span class="op">.</span>get_unchecked_mut(i) <span class="op">=</span> grand_total <span class="kw">as</span> <span class="dt">f64</span><span class="op">;</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>      n <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Only pass in the first `n` elements!</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r <span class="op">=</span> <span class="pp">utils::</span>correlation(<span class="op">&amp;</span>qs_totals[<span class="op">..</span>n]<span class="op">,</span> <span class="op">&amp;</span>grand_totals[<span class="op">..</span>n])<span class="op">;</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    (<span class="op">!</span>r<span class="op">.</span>is_nan())<span class="op">.</span>then_some((qs<span class="op">,</span> r))</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>)</span></code></pre></div>
<p>We run the benchmark again, and the new inner loop runs in
<strong>1.09 microseconds</strong>, which is 1.24 times faster than our
last iteration, and 32,940 times faster than our Python baseline. We’re
down to 46 minutes for the total computation.</p>
<p>(As an aside, it’s impressive that the heap allocator was fast enough
to have such a small impact on our runtime!)</p>
<p>In summary, Table <a href="#tbl:inner-speedup">1</a> shows the
runtime, relative speedup, absolute speedup, and total estimated
completion time for each level of the benchmark.</p>
<div id="tbl:inner-speedup">
<table style="width:100%;">
<caption>Table 1: Performance numbers for the inner loop.</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Level</th>
<th style="text-align: right;">Runtime</th>
<th style="text-align: right;">Speedup over previous level</th>
<th style="text-align: right;">Speedup over Python</th>
<th style="text-align: right;">Est. completion time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">python</td>
<td style="text-align: right;">35.85 ms</td>
<td style="text-align: right;"></td>
<td style="text-align: right;">1.00×</td>
<td style="text-align: right;">2.88 years</td>
</tr>
<tr class="even">
<td style="text-align: left;">0_basic</td>
<td style="text-align: right;">4.24 ms</td>
<td style="text-align: right;">8.46×</td>
<td style="text-align: right;">8.46×</td>
<td style="text-align: right;">124.40 days</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1_indexed</td>
<td style="text-align: right;">1.03 ms</td>
<td style="text-align: right;">4.11×</td>
<td style="text-align: right;">34.78×</td>
<td style="text-align: right;">30.25 days</td>
</tr>
<tr class="even">
<td style="text-align: left;">2_imap</td>
<td style="text-align: right;">180.52 μs</td>
<td style="text-align: right;">5.71×</td>
<td style="text-align: right;">198.60×</td>
<td style="text-align: right;">5.30 days</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3_bchecks</td>
<td style="text-align: right;">156.23 μs</td>
<td style="text-align: right;">1.16×</td>
<td style="text-align: right;">229.47×</td>
<td style="text-align: right;">4.59 days</td>
</tr>
<tr class="even">
<td style="text-align: left;">4_bitset</td>
<td style="text-align: right;">46.60 μs</td>
<td style="text-align: right;">3.35×</td>
<td style="text-align: right;">769.26×</td>
<td style="text-align: right;">1.37 days</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5_simd</td>
<td style="text-align: right;">1.35 μs</td>
<td style="text-align: right;">34.40×</td>
<td style="text-align: right;">26,459.54×</td>
<td style="text-align: right;">57.26 min</td>
</tr>
<tr class="even">
<td style="text-align: left;">6_alloc</td>
<td style="text-align: right;">1.09 μs</td>
<td style="text-align: right;">1.24×</td>
<td style="text-align: right;">32,940.02×</td>
<td style="text-align: right;">45.99 min</td>
</tr>
</tbody>
</table>
</div>
<p>The absolute speedup is summarized in Figure 1. Note that the y-axis
is on a log-scale!</p>
<figure>
<object data="speedup.svg" type="image/svg+xml" width="700" height="450">
</object>
<figcaption>
Performance trend of the inner loop.
</figcaption>
</figure>
<h2 id="parallelism">Parallelism</h2>
<p>At this point, we seem to have totally exhausted our avenues for
optimization. I actually can’t think of any other ways to make the inner
loop substantively faster — let me know if you have any ideas. But we’ve
left out one final, obvious trick: parallelism! This problem is
embarassingly parallel, so we can trivially parallelize the inner loop
over multiple cores. <a
href="https://docs.rs/rayon/1.8.0/rayon/index.html">Rayon</a> makes this
a breeze:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> all_qs <span class="op">=</span> questions<span class="op">.</span>indices()<span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>all_qs<span class="op">.</span>combinations(k)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>par_bridge()</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>map_init(</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">||</span> (<span class="pp">vec!</span>[<span class="dv">0</span><span class="op">.;</span> users<span class="op">.</span>len()]<span class="op">,</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">.;</span> users<span class="op">.</span>len()]<span class="op">,</span> <span class="pp">IndexSet::</span>new(<span class="op">&amp;</span>users))<span class="op">,</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>(qs_totals<span class="op">,</span> grand_totals<span class="op">,</span> user_set)<span class="op">,</span> qs<span class="op">|</span> <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">// same code as before</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// same code as before</span></span></code></pre></div>
<p>The <code>par_bridge</code> method takes a serial iterator and
converts it into a parallel iterator. The <code>map_init</code> function
is a parallel map with thread-specific state, so we preserve our
allocation-free status.</p>
<p>We need a different benchmark to evaluate the outer loop. I used
Criterion to run the outer loop over 5,000,000 question combinations in
a single run with a given strategy. This is enough executions to reveal
differences in each outer loop without waiting weeks for the benchmark
to complete.</p>
<p>Running this benchmark with the serial strategy over the fastest
inner loop takes <strong>6.8 seconds</strong>. My Macbook Pro has 10
cores, so with Rayon we should expect to see close to a 10x speedup.
After benchmarking the parallel strategy, we get… <strong>4.2
seconds</strong> to complete 5,000,000 combinations. That’s only a 1.6x
speedup! Shameful!</p>
<h2 id="batching">Batching</h2>
<p>Let’s go back to the profile to investigate our lack of scaling:</p>
<p><img src="img/profile-parallel.png" /></p>
<p>Our threads are spending most of their time locking and unlocking a
mutex! There’s some kind of synchronization bottleneck. Indeed, if we
read the <a
href="https://docs.rs/rayon/1.8.0/rayon/iter/trait.ParallelBridge.html"><code>par_bridge</code>
documentation</a> carefully, we’ll find a key sentence:</p>
<blockquote>
<p>Iterator items are pulled by <code>next()</code> one at a time,
synchronized from each thread that is ready for work, so this may become
a bottleneck if the serial iterator can’t keep up with the parallel
demand.</p>
</blockquote>
<p>It seems that the hand-off between the
<code>Itertools::combinations</code> iterator and the Rayon parallel
bridge is too slow. Given that we have a huge number of combinations, a
simple way to avoid this bottleneck is to increase the granularity of
task assignment. That is, we can batch together many question
combinations and pass them off to a thread all at once.</p>
<p>For this task, I defined a quick-and-dirty batching iterator that
uses an <a
href="https://docs.rs/arrayvec/0.7.4/arrayvec/struct.ArrayVec.html"><code>ArrayVec</code></a>
to avoid allocation.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Batched<span class="op">&lt;</span><span class="kw">const</span> N<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> I<span class="op">:</span> <span class="bu">Iterator</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  iter<span class="op">:</span> I<span class="op">,</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="kw">const</span> N<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> I<span class="op">:</span> <span class="bu">Iterator</span><span class="op">&gt;</span> <span class="bu">Iterator</span> <span class="cf">for</span> Batched<span class="op">&lt;</span>N<span class="op">,</span> I<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Item <span class="op">=</span> ArrayVec<span class="op">&lt;</span><span class="pp">I::</span>Item<span class="op">,</span> N<span class="op">&gt;;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">#[</span>inline<span class="at">]</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> batch <span class="op">=</span> <span class="pp">ArrayVec::</span>from_iter((<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span>iter)<span class="op">.</span>take(N))<span class="op">;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    (<span class="op">!</span>batch<span class="op">.</span>is_empty())<span class="op">.</span>then_some(batch)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Then we modify our outer loop by batching the combinations iterator,
and modify the inner loop to flatten each batch:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> all_qs <span class="op">=</span> questions<span class="op">.</span>indices()<span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>all_qs<span class="op">.</span>combinations(k)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="pp">batched::</span><span class="op">&lt;</span><span class="dv">1024</span><span class="op">&gt;</span>()</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>par_bridge()</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>map_init(</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">||</span> (<span class="pp">vec!</span>[<span class="dv">0</span><span class="op">.;</span> users<span class="op">.</span>len()]<span class="op">,</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">.;</span> users<span class="op">.</span>len()]<span class="op">,</span> <span class="pp">IndexSet::</span>new(<span class="op">&amp;</span>users))<span class="op">,</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span>(qs_totals<span class="op">,</span> grand_totals<span class="op">,</span> user_set)<span class="op">,</span> qs_batch<span class="op">|</span> <span class="op">{</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      qs_batch</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>into_iter()</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>filter_map(<span class="op">|</span>qs<span class="op">|</span> <span class="op">{</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>          <span class="co">// same code as before</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>collect_vec()</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>flatten()</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// same code as before</span></span></code></pre></div>
<p>Running the outer-loop benchmark again, the chunking iterator now
completes 5,000,000 combinations in <strong>982 milliseconds</strong>.
This is a 6.9x speedup over the serial approach, which is much better
for our 10-core machine. Ideally we would get closer to 10x, but I think
this post is long enough. In summary, our outer loop runtime numbers are
in Table <a href="#tbl:outer-loop">2</a>.</p>
<div id="tbl:outer-loop">
<table style="width:100%;">
<caption>Table 2: Performance numbers for the outer loop.</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Level</th>
<th style="text-align: right;">Runtime</th>
<th style="text-align: right;">Speedup over previous level</th>
<th style="text-align: right;">Speedup over Python</th>
<th style="text-align: right;">Est. completion time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0_serial</td>
<td style="text-align: right;">6.80 s</td>
<td style="text-align: right;"></td>
<td style="text-align: right;">26,342.63×</td>
<td style="text-align: right;">57.51 min</td>
</tr>
<tr class="even">
<td style="text-align: left;">1_parallel</td>
<td style="text-align: right;">4.22 s</td>
<td style="text-align: right;">1.61×</td>
<td style="text-align: right;">42,439.31×</td>
<td style="text-align: right;">35.70 min</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2_batched</td>
<td style="text-align: right;">982.46 ms</td>
<td style="text-align: right;">4.30×</td>
<td style="text-align: right;">182,450.94×</td>
<td style="text-align: right;">8.30 min</td>
</tr>
</tbody>
</table>
</div>
<h2 id="conclusion">Conclusion</h2>
<p>So how far did we come? The original Python program was going to take
2.9 years to complete at k=5. Our final Rust program only takes
<strong>8 minutes</strong> on the same dataset. That is roughly a
<strong>180,000x speedup</strong>. A summary of the key
optimizations:</p>
<ul>
<li>Use Rust’s compiler optimizations.</li>
<li>Hash numbers instead of strings.</li>
<li>Use (indexed) vectors instead of hashmaps.</li>
<li>Use bit-sets for efficient membership tests.</li>
<li>Use SIMD for efficient bit-sets.</li>
<li>Use multi-threading to split the work over many cores.</li>
<li>Use batching to avoid a bottleneck at work distribution.</li>
</ul>
<p>Can we do better? Let’s take one last look at the profile:</p>
<p><img src="img/profile-batched.png" /></p>
<p>We’re spending 38% of our time in the bit-set iterator, and 36% of
our time in the bit-set intersection. Another 12% in copying the initial
bit-set for a given set of questions. And a long tail of other
operations like computing the correlation.</p>
<p>I tried my best to make the SIMD bit-set implementation fast, so I
don’t know of a way to improve these numbers. We might find another +10%
speedup from careful tweaking of the various constants (lane size, batch
size, etc.), but I don’t think there’s another order of magnitude left
on the table. If you know of a way, I invite you to try it out:<br> <a
href="https://github.com/willcrichton/corrset-benchmark"
class="uri">https://github.com/willcrichton/corrset-benchmark</a></p>
<p>Also if you know of an analytic solution to this problem, i.e., a
smarter way to get an optimal answer without brute force, do let me know
as well! Otherwise, I hope you learned a bit about performance
engineering in Rust.</p>
<h2 id="addendum-103023">Addendum (10/30/23)</h2>
<p>This post generated a fair amount of engagement on <a
href="https://www.reddit.com/r/rust/comments/17cmmql/analyzing_data_180000x_faster_with_rust/">/r/rust</a>
and <a href="https://news.ycombinator.com/item?id=37964161">HN</a>. I
wanted to share a few things people have tried.</p>
<ul>
<li>Sidney Radcliffe showed how to match Rust’s performance using the <a
href="https://numba.pydata.org/">Numba</a> JIT in the Numba subset of
Python. Check out the post <a
href="https://sidsite.com/posts/python-corrset-optimization/">“Analyzing
Data 170,000x Faster with Python”</a>. I added <a
href="https://github.com/willcrichton/corrset-benchmark/blob/main/python/corrset_numba.py">corrset_numba.py</a>
to the <code>python/</code> directory of the benchmark.</li>
<li>katopz showed how to implement the Python example using the <a
href="https://www.pola.rs/">polars</a> library (a Rust implementation of
Pandas-like dataframes). This implementation seems to be about 3.5 times
faster than the original Python baseline. I added <a
href="https://github.com/willcrichton/corrset-benchmark/blob/main/python/corrset_polars.py">corrset_polars.py</a>
to the <code>python/</code> directory of the benchmark.</li>
<li>cjcormier <a
href="https://github.com/willcrichton/corrset-benchmark/pull/2">pointed
out</a> a clever optimization: between the two combinations
<code>[0, 1, 2, 3, 4]</code> and <code>[0, 1, 2, 3, 5]</code>, if we
store the bit-set representing the intersection of
<code>[0, 1, 2, 3]</code>, then we can compute the bit-set for
<code>5</code> and <code>6</code> with only one intersection rather than
five (or more generally, rather than
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>
intersections). Put another way, if we fuse the combinations iterator
and the bit-set intersections, we can trade-off memory for performance.
I implemented cjcormier’s strategy in <a
href="https://github.com/willcrichton/corrset-benchmark/blob/main/src/fused.rs">fused.rs</a>
and it achieves a <strong>1.28x speedup</strong> over my previous
personal record, reducing the total computation time of k=5 from 10.3
minutes to 8.0 minutes. Thanks Chris!</li>
</ul>
</body>
</html>