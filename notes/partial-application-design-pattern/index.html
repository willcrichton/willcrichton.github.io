<!DOCTYPE html>
<!--
 _    _ _ _ _   _____      _      _     _
| |  | (_) | | /  __ \    (_)    | |   | |
| |  | |_| | | | /  \/_ __ _  ___| |__ | |_ ___  _ __
| |/\| | | | | | |   | '__| |/ __| '_ \| __/ _ \| '_ \
\  /\  / | | | | \__/\ |  | | (__| | | | || (_) | | | |
 \/  \/|_|_|_| \_____/_|  |_|\___|_| |_|\__\___/|_| |_|
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description"
          content="Partial function application, or currying, is omnipresent in the use of functional languages. I discuss its role as a design pattern, looking at three specific ways currying can improve the brevity and readability of an API.">
    
    
    <title>
      
      Partial Function Application as a Design Pattern | Will Crichton
      
    </title>
    
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,500,700,700i,900" rel="stylesheet">
    <link rel="stylesheet" href="/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/css/tango.css" />
    <link rel="stylesheet" href="/css/main.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
    
    
    <div style="display:none;">
      $$
      % Typography and symbols
      \newcommand{\msf}[1]{\mathsf{#1}}
      \newcommand{\ctx}{\Gamma}
      \newcommand{\qamp}{&\quad}
      \newcommand{\qqamp}{&&\quad}
      \newcommand{\Coloneqq}{::=}
      \newcommand{\proves}{\vdash}
      \newcommand{\star}[1]{#1^{*}}
      \newcommand{\eps}{\varepsilon}
      \newcommand{\brc}[1]{\{{#1}\}}

      % Untyped lambda calculus
      \newcommand{\fun}[2]{\lambda ~ {#1} ~ . ~ {#2}}
      \newcommand{\app}[2]{#1 ~ #2}

      % Typed lambda calculus - expressions
      \newcommand{\funt}[3]{\lambda ~ \left(#1 : #2\right) ~ . ~ #3}
      \newcommand{\lett}[4]{\msf{let} ~ \hasType{#1}{#2} = #3 ~ \msf{in} ~ #4}
      \newcommand{\rec}[3]{\msf{rec}(#1; ~ x.y.#2)(#3)}
      \newcommand{\case}[5]{\msf{case} ~ {#1} ~ \{ L(#2) \to #3 \mid R(#4) \to #5 \}}
      \newcommand{\pair}[2]{\left({#1},{#2}\right)}
      \newcommand{\proj}[2]{#1 . #2}
      \newcommand{\inj}[3]{\msf{inj} ~ #1 = #2 ~ \msf{as} ~ #3}
      \newcommand{\letv}[3]{\msf{let} ~ {#1} = {#2} ~ \msf{in} ~ {#3}}

      % Typed lambda calculus - types
      \newcommand{\tprod}[2]{#1 \times #2}
      \newcommand{\tsum}[2]{#1 + #2}

      % WebAssembly
      \newcommand{\wconst}[1]{\msf{i32.const}~{#1}}
      \newcommand{\wbinop}[1]{\msf{i32}.{#1}}
      \newcommand{\wgetlocal}[1]{\msf{get\_local}~{#1}}
      \newcommand{\wsetlocal}[1]{\msf{set\_local}~{#1}}
      \newcommand{\wload}{\msf{i32.load}}
      \newcommand{\wstore}{\msf{i32.store}}
      \newcommand{\wsize}{\msf{memory.size}}
      \newcommand{\wgrow}{\msf{memory.grow}}
      \newcommand{\wunreachable}{\msf{unreachable}}
      \newcommand{\wblock}[1]{\msf{block}~{#1}}
      \newcommand{\wblockr}[2]{\msf{block}~{#1}~{#2}}
      \newcommand{\wloop}[1]{\msf{loop}~{#1}}
      \newcommand{\wbr}[1]{\msf{br}~{#1}}
      \newcommand{\wbrif}[1]{\msf{br\_if}~{#1}}
      \newcommand{\wreturn}{\msf{return}}
      \newcommand{\wcall}[1]{\msf{call}~{#1}}
      \newcommand{\wlabel}[3]{\msf{label}_{#1}~\{#2\}~{#3}}
      \newcommand{\wframe}[1]{\msf{frame}~{#1}}
      \newcommand{\wtrapping}{\msf{trapping}}
      \newcommand{\wbreaking}[2]{\msf{breaking}_{#1}~{#2}}
      \newcommand{\wreturning}[1]{\msf{returning}~{#1}}
      \newcommand{\wconfig}[5]{\{\msf{module}~{#1};~\msf{mem}~{#2};~\msf{locals}~{#3};~\msf{stack}~{#4};~\msf{instrs}~{#5}\}}
      \newcommand{\wfunc}[3]{\{\msf{params}~{#1};~\msf{locals}~{#2};~\msf{body}~{#3}\}}
      \newcommand{\wmodule}[1]{\{\msf{funcs}~{#1}\}}

      \newcommand{\semi}[2]{{#1};~{#2}}
      \newcommand{\semii}[3]{{#1};~{#2};~{#3}}
      \newcommand{\semiii}[4]{{#1};~{#2};~{#3};~{#4}}
      \newcommand{\semiiii}[5]{{#1};~{#2};~{#3};~{#4};~{#5}}
      \newcommand{\wci}{\msf{instrs}}
      \newcommand{\wcs}{\msf{stack}}
      \newcommand{\wcl}{\msf{locals}}
      \newcommand{\wcm}{\msf{mem}}
      \newcommand{\wcmod}{\msf{module}}
      \newcommand{\wsteps}[2]{\steps{\brc{#1}}{\brc{#2}}}

      % Inference rules
      \newcommand{\inferrule}[3][]{\cfrac{#2}{#3}\;{#1}}
      \newcommand{\ir}[3]{\inferrule[\text{(#1)}]{#2}{#3}}
      \newcommand{\s}{\hspace{1em}}
      \newcommand{\nl}{\\[2em]}
      \newcommand{\steps}[2]{#1 \boldsymbol{\mapsto} #2}
      \newcommand{\subst}[3]{[#1 \rightarrow #2] ~ #3}
      \newcommand{\dynJ}[2]{#1 \proves #2}
      \newcommand{\dynJC}[1]{\dynJ{\ctx}{#1}}
      \newcommand{\typeJ}[3]{#1 \proves \hasType{#2}{#3}}
      \newcommand{\typeJC}[2]{\typeJ{\ctx}{#1}{#2}}
      \newcommand{\hasType}[2]{#1 : #2}
      \newcommand{\val}[1]{#1~\msf{val}}
      \newcommand{\num}[1]{\msf{Int}(#1)}
      \newcommand{\err}[1]{#1~\msf{err}}
      \newcommand{\trans}[2]{#1 \leadsto #2}
      \newcommand{\size}[1]{\left|#1\right|}
      $$
    </div>
    
    
  </head>
  <body>
    <div class="container note">
  <h1 class="site-title"><a href="/notes">&Notepad</a></h1>
  <h1>
    
    Partial Function Application as a Design Pattern
    
  </h1>
  <div class="date">
    
    Will Crichton
    
    &nbsp; &mdash; &nbsp;
    January 4, 2019
  </div>
  <div class="abstract">Partial function application, or currying, is omnipresent in the use of functional languages. I discuss its role as a design pattern, looking at three specific ways currying can improve the brevity and readability of an API.</div>
  <p>Partial function application is a common feature of functional programming languages where functions can be given some, but not all, of their arguments. As a simple example, we can curry an “add” function in OCaml to produce a more specialized function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* In non-functional languages, multiple arguments are given as tuples *)</span>
<span class="k">let</span> <span class="n">add</span> <span class="p">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">in</span>

<span class="k">assert</span> <span class="p">(</span><span class="n">add</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">);</span>

<span class="c">(* An explicit curried style makes a new function for each argument *)</span>
<span class="k">let</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="p">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="p">(</span><span class="n">b</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">in</span>

<span class="k">let</span> <span class="n">add2</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">2</span> <span class="k">in</span>

<span class="k">assert</span> <span class="p">(</span><span class="n">add</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">5</span><span class="p">);</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">add2</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">5</span><span class="p">);</span>

<span class="c">(* OCaml (like other functional languages) supports implicit currying *)</span>
<span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c">(* This still works. The type of add is int -&gt; int -&gt; int *)</span>
<span class="k">let</span> <span class="n">add4</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">4</span> <span class="k">in</span>

<span class="k">assert</span> <span class="p">(</span><span class="n">add4</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">7</span><span class="p">)</span>
</code></pre></div></div>

<p>If you’re not as familiar with functional language syntax, here’s the equivalent in Javascript:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">add2</span> <span class="o">=</span> <span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">add2</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<p>In this note, I want to move beyond the mechanics of currying to ask: how can partial application help you improve the design of your libraries?</p>

<h2 id="1-argument-frequency-of-change">1. Argument frequency of change</h2>

<p>One rule of thumb for currying is to order your arguments from left to right in terms of <em>increasing frequency of change</em>. For example, consider an API for querying a database:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Database</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">connection</span>
  <span class="k">type</span> <span class="n">row</span>

  <span class="k">val</span> <span class="n">connect</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">connection</span>
  <span class="k">val</span> <span class="n">select</span> <span class="o">:</span> <span class="n">connection</span> <span class="o">-&gt;</span> <span class="n">table</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">column</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">row</span> <span class="kt">list</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">DatabaseTest</span><span class="p">(</span><span class="nc">Db</span> <span class="o">:</span> <span class="nc">Database</span><span class="p">)</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Db</span><span class="p">.</span><span class="n">connect</span> <span class="bp">()</span> <span class="k">in</span>

  <span class="c">(* Verbose repetition between selects... :( *)</span>
  <span class="k">let</span> <span class="n">firstnames</span> <span class="o">=</span> <span class="nn">Db</span><span class="p">.</span><span class="n">select</span> <span class="n">c</span> <span class="o">~</span><span class="n">table</span><span class="o">:</span><span class="s2">"users"</span> <span class="o">~</span><span class="n">column</span><span class="o">:</span><span class="s2">"firstname"</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lastnames</span> <span class="o">=</span> <span class="nn">Db</span><span class="p">.</span><span class="n">select</span> <span class="n">c</span> <span class="o">~</span><span class="n">table</span><span class="o">:</span><span class="s2">"users"</span> <span class="o">~</span><span class="n">column</span><span class="o">:</span><span class="s2">"lastname"</span> <span class="k">in</span>

  <span class="c">(* Curry over the database connection *)</span>
  <span class="k">let</span> <span class="n">select</span> <span class="o">=</span> <span class="nn">Db</span><span class="p">.</span><span class="n">select</span> <span class="n">c</span> <span class="k">in</span>

  <span class="c">(* Curry over the table *)</span>
  <span class="k">let</span> <span class="n">selectuser</span> <span class="o">=</span> <span class="n">select</span> <span class="o">~</span><span class="n">table</span><span class="o">:</span><span class="s2">"users"</span> <span class="k">in</span>

  <span class="c">(* Concise column access! :) *)</span>
  <span class="k">let</span> <span class="n">firstnames</span> <span class="o">=</span> <span class="n">selectuser</span> <span class="o">~</span><span class="n">column</span><span class="o">:</span><span class="s2">"firstname"</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">firstnames</span> <span class="o">=</span> <span class="n">selectuser</span> <span class="o">~</span><span class="n">column</span><span class="o">:</span><span class="s2">"lastnames"</span> <span class="k">in</span>

  <span class="bp">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>For the <code class="highlighter-rouge">select</code> function, the database connection is going to change the <em>least</em> frequently. We usually connect to a database and run many queries. Then the table is next least frequent to change, as we may select multiple columns from a table (as in this example). So we can provide our parameters in order, and now the user can iteratively whittle down their helper functions until they need the minimal number of arguments to get the job done. How concise!</p>

<p>Two interesting nuances here. First, if we use named arguments (e.g. <code class="highlighter-rouge">table</code> and <code class="highlighter-rouge">column</code> above), we aren’t restricted to currying in the left-to-right ordering. For example, we could curry on the column and leave the table unspecified without changing the original function definition:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">select_firstname</span> <span class="o">:</span> <span class="n">table</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">row</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="nn">Db</span><span class="p">.</span><span class="n">select</span> <span class="n">c</span> <span class="o">~</span><span class="n">column</span><span class="o">:</span><span class="s2">"firstname"</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">firstnames</span> <span class="o">=</span> <span class="n">select_firstname</span> <span class="o">~</span><span class="n">table</span><span class="o">:</span><span class="s2">"users"</span>
</code></pre></div></div>

<p>This means the left-to-right rule only applies for anonymous arguments, not named arguments.</p>

<p>Second, you could interpret this idiom as approaching the expressiveness of an object-oriented interface, but without objects. A common approach to this type of configuration-minimizing design pattern would be to have a Database object that is configured once and offers methods that can access the configuration. For example, in Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Database</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">connect_to_db</span><span class="p">()</span>

   <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
     <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">Database</span><span class="p">()</span>
<span class="n">firstnames</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s">'users'</span><span class="p">,</span> <span class="s">'firstname'</span><span class="p">)</span>

<span class="c"># Explicit currying by creating new functions</span>
<span class="n">selectuser</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">column</span><span class="p">:</span> <span class="n">db</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s">'users'</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
<span class="n">lastnames</span> <span class="o">=</span> <span class="n">selectuser</span><span class="p">(</span><span class="s">"lastname"</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that currying allows us to both avoid redundant configuration while also enabling expressive use of methods, while OOP languages like Python et al. only easily permit the former.</p>

<h2 id="2-readable-method-chains">2. Readable method chains</h2>

<p>One wonderful part of object-oriented interfaces is the use of method chains to express sequences of actions in a readable left/right, top/bottom fashion. For example in Rust, I can make a space-separated string of all the even numbers in a list like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
  <span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">v</span>
    <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="nf">.filter</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span> <span class="n">n</span><span class="nf">.to_string</span><span class="p">())</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="nf">.join</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c">// 2 4</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I would consider this readable in the sense that to follow the sequence of events, I can read top-down in a natural fashion, and understand the state of the list at each point. “Ok, first we have the list, then it’s an iterator, then we get the event numbers, then we turn each one into a string, convert it back into a list, then join it into a final string.”</p>

<p>By contrast, a common problem in function-oriented interfaces is the “inside-out” problem:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l</span><span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span> <span class="k">in</span>
<span class="nn">List</span><span class="p">.</span><span class="n">join</span> <span class="s2">" "</span>
  <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">string_of_int</span>
    <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">l</span><span class="p">))</span>
</code></pre></div></div>

<p>To read this sequence of operations, I have to scan to find the inner-most operation, then start reading from the inside out to follow the sequence. I personally find this onerous for the same reason as reading prefix or postfix arithmetic: the order of operations does not follow the order of reading.</p>

<p>However, with some clever usage of currying and function combinators, we can turn this around. First, in OCaml, there is an infix “pipe” operator that calls a function on the right with an argument on the left.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="o">|&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span>
<span class="k">in</span>

<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">]</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">l'</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">in</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">l'</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<p>With this operator in hand, we carefully design our operations to take their primary object as the <em>last</em> argument. For example, the map and filter functions on lists have these type signatures:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="kt">list</span>
<span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
</code></pre></div></div>

<p>Note that the transforming functions come first, and the target list (<code class="highlighter-rouge">'a list</code>) comes last (right before the output). With our API ordered like this, we can then rewrite the inside-out example:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l</span><span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span> <span class="k">in</span>

<span class="n">l</span>
<span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">string_of_int</span>
<span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">join</span> <span class="s2">" "</span>
</code></pre></div></div>

<p>Wow! Almost like normal method chaining. The main difference here is that we still have to explicitly reference the <code class="highlighter-rouge">List</code> module where the function was defined. In an object oriented interface, we can just say <code class="highlighter-rouge">l.filter(..)</code> because the compiler determines which function <code class="highlighter-rouge">filter</code> refers to from the type of <code class="highlighter-rouge">l</code>. That is to say, object-oriented interfaces use <em>type-directed</em> name resolution, while functional interfaces use <em>explicit</em> name resolution<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>.</p>

<h2 id="3-concise-embedded-dsls">3. Concise embedded DSLs</h2>

<p>Another great use of currying is to create combinator-based embedded domain specific languages. For example, I was working today on an OCaml interface inspired by the <a href="https://en.wikipedia.org/wiki/Allen%27s_interval_algebra">Allen interval algebra</a> which defines different relations on time intervals. The goal was to have an interface that lets me quickly combine different interval comparisons to create new operators. To define an “interval is near” function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">open</span> <span class="nc">IntervalAlgebra</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">is_near</span> <span class="o">:</span> <span class="n">interval</span> <span class="o">-&gt;</span> <span class="n">interval</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span>
  <span class="n">overlaps</span> <span class="o">||</span>
  <span class="p">(</span><span class="n">before</span> <span class="o">~</span><span class="n">max_dist</span><span class="o">:</span><span class="p">(</span><span class="nc">Some</span> <span class="mi">10</span><span class="o">.</span><span class="p">))</span> <span class="o">||</span>
  <span class="p">(</span><span class="n">after</span> <span class="o">~</span><span class="n">max_dist</span><span class="o">:</span><span class="p">(</span><span class="nc">Some</span> <span class="mi">10</span><span class="o">.</span><span class="p">))</span>
<span class="k">in</span>

<span class="k">let</span> <span class="n">ai</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.;</span> <span class="n">end_</span> <span class="o">=</span> <span class="mi">10</span><span class="o">.</span><span class="p">}</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">bi</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span> <span class="o">=</span> <span class="mi">12</span><span class="o">.;</span> <span class="n">end_</span> <span class="o">=</span> <span class="mi">14</span><span class="o">.</span><span class="p">}</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">ci</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span> <span class="o">=</span> <span class="mi">25</span><span class="o">.;</span> <span class="n">end_</span> <span class="o">=</span> <span class="mi">27</span><span class="o">.</span><span class="p">}</span> <span class="k">in</span>

<span class="k">assert</span> <span class="p">(</span><span class="n">is_near</span> <span class="n">ai</span> <span class="n">bi</span><span class="p">);</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">in_near</span> <span class="n">ai</span> <span class="n">ci</span><span class="p">))</span>
</code></pre></div></div>

<p>I call this an embedded DSL since it repurposes syntax, e.g. the or operator <code class="highlighter-rouge">||</code> isn’t combining boolean values, but instead functions that produce boolean values. I was able to implement this interface without much trouble using currying:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">IntervalAlgebra</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">interval</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span> <span class="n">end_</span><span class="o">:</span> <span class="kt">float</span><span class="p">}</span>

  <span class="k">let</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">ai</span> <span class="o">:</span> <span class="n">interval</span><span class="p">)</span> <span class="p">(</span><span class="n">bi</span> <span class="o">:</span> <span class="n">interval</span><span class="p">)</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span>
    <span class="n">ai</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">bi</span><span class="o">.</span><span class="n">end_</span> <span class="o">&amp;&amp;</span> <span class="n">ai</span><span class="o">.</span><span class="n">end_</span> <span class="o">&gt;=</span> <span class="n">bi</span><span class="o">.</span><span class="n">start</span>

  <span class="k">let</span> <span class="n">before</span> <span class="o">?</span><span class="p">(</span><span class="n">max_dist</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span><span class="p">)</span> <span class="p">(</span><span class="n">ai</span> <span class="o">:</span> <span class="n">interval</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bi</span> <span class="o">:</span> <span class="n">interval</span><span class="p">)</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">bi</span><span class="o">.</span><span class="n">start</span> <span class="o">-.</span> <span class="n">ai</span><span class="o">.</span><span class="n">end_</span> <span class="k">in</span>
    <span class="k">match</span> <span class="n">max_dist</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">dist</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">.</span> <span class="o">&lt;=</span> <span class="n">diff</span> <span class="o">&amp;&amp;</span> <span class="n">diff</span> <span class="o">&lt;=</span> <span class="n">dist</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">.</span> <span class="o">&lt;=</span> <span class="n">diff</span>

  <span class="k">let</span> <span class="n">after</span> <span class="o">?</span><span class="p">(</span><span class="n">max_dist</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span><span class="p">)</span> <span class="p">(</span><span class="n">ai</span> <span class="o">:</span> <span class="n">interval</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bi</span> <span class="o">:</span> <span class="n">interval</span><span class="p">)</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span>
    <span class="n">before</span> <span class="o">~</span><span class="n">max_dist</span> <span class="n">bi</span> <span class="n">ai</span>

  <span class="k">let</span> <span class="p">(</span><span class="o">||</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">g</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">let</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">g</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I use currying in two ways here: first, currying allows operators to have parameters, e.g. the <code class="highlighter-rouge">before</code> and <code class="highlighter-rouge">after</code> operators have an optional <code class="highlighter-rouge">max_dist</code> parameter that is provided once, and used every time the operator is called. Second, I use currying to define the higher-order operator combinators (the <code class="highlighter-rouge">||</code> and <code class="highlighter-rouge">&amp;&amp;</code>). Calling <code class="highlighter-rouge">before || after</code> fills in the values of <code class="highlighter-rouge">f</code> and <code class="highlighter-rouge">g</code>, but then return a new function waiting for the intervals <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> before calling them appropriately.</p>

<p>If you use currying in cool ways beyond what’s shown here, please leave a note <a href="">in the comments</a> or send me an email at <a href="mailto:wcrichto@cs.stanford.edu">wcrichto@cs.stanford.edu</a>.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Languages with type classes (like Haskell) or traits (like Rust) use type-directed name resolution without objects. See my post on <a href="/notes/specificity-programming-languages/">Name Resolution in Programming Languages</a> for more. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-16662292-3"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());
     gtag('config', 'UA-16662292-3');
    </script>

    <!-- Mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full" type="text/javascript"></script>
    <script type="text/javascript">
     MathJax.Hub.Config({
       messageStyle: "none",
       tex2jax: {inlineMath: [['($', '$)'], ['\\(','\\)']]},
       "HTML-CSS": {
         fonts: ["TeX"]
       }
     });
     MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
       console.error(message[2]);
     });
     MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
       console.error(message[1]);
     });
    </script>
  </body>
</html>
