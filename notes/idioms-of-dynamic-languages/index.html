<!DOCTYPE html>
<!--
 _    _ _ _ _   _____      _      _     _
| |  | (_) | | /  __ \    (_)    | |   | |
| |  | |_| | | | /  \/_ __ _  ___| |__ | |_ ___  _ __
| |/\| | | | | | |   | '__| |/ __| '_ \| __/ _ \| '_ \
\  /\  / | | | | \__/\ |  | | (__| | | | || (_) | | | |
 \/  \/|_|_|_| \_____/_|  |_|\___|_| |_|\__\___/|_| |_|
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description"
          content="Programmers think dynamic languages like Python are easier to use than static ones, but why? I look at uniquely dynamic programming idioms and their static alternatives, identifying a few broad trends that impact language usability.">
    
    
    <title>
      
      Idioms of Dynamic Languages | Will Crichton
      
    </title>
    
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,500,700,700i,900" rel="stylesheet">
    <link rel="stylesheet" href="/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/css/tango.css" />
    <link rel="stylesheet" href="/css/main.css" />
  </head>
  <body>
    <div class="container note">
  <h1 class="site-title"><a href="/notes">&Notepad</a></h1>
  <h1>
    
    Idioms of Dynamic Languages
    
  </h1>
  <div class="date">July 1, 2018</div>
  <div class="abstract">Programmers think dynamic languages like Python are easier to use than static ones, but why? I look at uniquely dynamic programming idioms and their static alternatives, identifying a few broad trends that impact language usability.</div>
  <p>Here’s a fact: a lot of people use dynamic languages<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. The web world is the most prominent use case, having both frontend and backend often written in dynamic languages (Python, PHP, Ruby, Javascript), but these languages are also widespread in other fields like data science (Python, R, Matlab, Julia), game scripting (Lua), hardware (Perl), and more. Dynamic languages are increasingly used for introductory computer science education—Stanford’s new <a href="https://web.stanford.edu/class/cs106j/handouts/01-GeneralInformation.pdf">CS 106J</a> uses Javascript, Berkeley’s <a href="https://cs61a.org/">CS 61A</a> and CMU’s <a href="https://www.cs.cmu.edu/~112/">15-112</a> use Python, and Brown’s <a href="http://cs.brown.edu/courses/csci0190/2018/">CSCI 0190</a> uses Racket. Even the College Board is moving its new <a href="https://apcentral.collegeboard.org/courses/ap-computer-science-principles/course">AP CS Principles</a> away from Java and towards dynamic languages.</p>

<p>Since dynamic languages are so popular, we ought to better understand what drives their adoption. This question is part of the classic static vs. dynamic typing debate, which has been discussed at length with <a href="https://danluu.com/empirical-pl/">evidence</a> and <a href="http://wiki.c2.com/?BenefitsOfDynamicTyping">anecdotes</a> (and arguably, no strong conclusion has been reached). While many factors influence the selection of a language for any given purpose, I think it’s mostly uncontroversial to say: programmers like dynamic languages because they feel easy to learn and use in contrast to more safe, static languages (e.g. Java, C#, C++, OCaml, Rust, …), particularly for small programs and prototypes.</p>

<p>If this is the case, then what makes dynamic languages <em>feel</em> easy? Can we take what we learn in answering this question and improve the ergonomics of our static languages? For example, in 2018, I don’t think there’s as strong an argument for “you don’t have to write out the types,” since modern type inference eliminates most of the keystrokes required (even though many major languages still lack such facilities). Plus, saving a few keystrokes does not seem like a critical bottleneck in the programming process.</p>

<p>Instead, my running hypothesis is that <em class="hl">a major source of friction in statically typed languages is an impedance mismatch between a programmer’s mental model of her program and the mental model imposed by the programming language</em>. Put another way, a programming language’s type system encodes certain opinions about how a program <em>must</em> be structured, and when those opinions differ from the programmer’s, conflict ensues. Let’s walk through a few examples to demonstrate this idea.</p>

<h2 id="1-dynamic-heterogeneous-data-structures">1. Dynamic heterogeneous data structures</h2>

<p>In dynamic languages, it’s common to have data structures like dictionaries that mix and match values of different types. This is particularly common when dealing with data types like JSON, or any data where it’s hard to predict ahead of time what the data format will be.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Python</span>
<span class="n">my_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">my_dict</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">my_dict</span><span class="p">[</span><span class="mi">200</span><span class="p">]</span> <span class="o">=</span> <span class="s">'Hello world!'</span>
<span class="c"># No problem!</span>
</code></pre></div></div>

<p>We can use two axes to describe the kinds of behavior occuring here and how it relates to static languages. The first is static vs. dynamic, or whether the size/shape of the data structure changes at runtime. For example, if we have:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
  <span class="n">age</span><span class="p">:</span> <span class="nb">i32</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">will</span> <span class="o">=</span> <span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Will"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">age</span><span class="p">:</span> <span class="mi">24</span> <span class="p">};</span>
<span class="n">will</span><span class="py">.job</span> <span class="o">=</span> <span class="s">"Student"</span><span class="p">;</span> <span class="c">// Not valid!</span>
</code></pre></div></div>

<p>In a static language like Rust, a predefined struct is a static data structure, as we cannot add or remove keys at runtime. By contrast:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">let</span> <span class="n">job_map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">job_map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">will</span><span class="py">.name</span><span class="p">,</span> <span class="s">"Student"</span><span class="p">);</span>
</code></pre></div></div>

<p>A map (or a set, vector, etc.) is a dynamic data structure, as you can add/remove key/value pairs at runtime. The other axis is homogeneous vs. heterogeneous, or whether a data structure can contain multiple values of different types. A struct can be heterogeneous, e.g. the <code class="highlighter-rouge">Person</code> above contains a string and a number, while the <code class="highlighter-rouge">HashMap</code> is homogeneous:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">let</span> <span class="n">map</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">"Hello world"</span><span class="p">);</span> <span class="c">// Error! Map value must be i32, not String</span>
</code></pre></div></div>

<p>Depending on the language, there are multiple ways to implement the desired heterogeneity.</p>

<ol>
  <li><strong><a href="https://www.javaworld.com/article/2075223/core-java/reveal-the-magic-behind-subtype-polymorphism.html">Subtype polymorphism</a>:</strong> In a class-based language like Java, one can cast all the objects a superclass like <code class="highlighter-rouge">Object</code>:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Java</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="o">(</span><span class="n">Object</span><span class="o">)</span> <span class="mi">0</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span> <span class="o">(</span><span class="n">Object</span><span class="o">)</span> <span class="mi">200</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="n">String</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">200</span><span class="o">));</span>
</code></pre></div>    </div>
    <p><strong>Pros</strong>: little syntactic overhead, no restriction on sets of types that can be placed in the container.<br />
<strong>Cons</strong>: requires explicit typecasts in and out of the container, runtime errors possible.</p>
  </li>
  <li><strong><a href="https://doc.rust-lang.org/std/any/">Any types</a>:</strong> Static languages that support dynamic typing at runtime can use an Any type (or better yet, <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Obj.html">Obj.magic</a>):
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Any</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"Hello world"</span><span class="nf">.to_string</span><span class="p">()));</span>

<span class="k">match</span> <span class="n">map</span><span class="p">[</span><span class="o">&amp;</span><span class="mi">200</span><span class="p">]</span><span class="py">.downcast_ref</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">s</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
  <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error"</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>    </div>
    <p>Fairly similar to the <code class="highlighter-rouge">Object</code> approach in class-based languages, roughly same set of tradeoffs (although here, Rust uses an explicit error handling approach for cast errors instead of exceptions as in Java).</p>
  </li>
  <li><strong><a href="https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html">Trait polymorphism</a>:</strong> In a trait/typeclass-based language like Rust or Haskell, one can upcast to a trait:
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">trait</span> <span class="n">ToString</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span> <span class="p">}</span>
<span class="k">let</span> <span class="n">map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">ToString</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"Hello world"</span><span class="p">));</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">map</span><span class="p">[</span><span class="o">&amp;</span><span class="mi">200</span><span class="p">]</span><span class="nf">.to_string</span><span class="p">());</span>
</code></pre></div>    </div>
    <p><strong>Pros</strong>: type-safe, no runtime errors, little syntactic overhead.<br />
<strong>Cons</strong>: requires identifying the subset of functionality you need common to each type and aliasing to that trait (this is also true in subtyping systems that don’t permit runtime downcasts).<br /></p>
    <blockquote>
      <p>Note: this idea is related to the idea of “existential types” in programming language theory.</p>
    </blockquote>
  </li>
  <li><strong>Sum types</strong>: Sum types (or unions, enums, variants, etc.) allow the definition of types that could be one of many things. Sum types take many forms, with three primary tradeoffs:
    <ol>
      <li><strong>Named vs. anonymous</strong>: sum types in OCaml, Haskell, and Rust all have named branches. For example:
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">enum</span> <span class="n">MyValue</span> <span class="p">{</span>
  <span class="nf">Int</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
  <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="n">MyValue</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="nn">MyValue</span><span class="p">::</span><span class="nf">Int</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nn">MyValue</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="s">"Hello world"</span><span class="nf">.into</span><span class="p">()));</span>

<span class="k">match</span> <span class="n">map</span><span class="p">[</span><span class="o">&amp;</span><span class="mi">200</span><span class="p">]</span> <span class="p">{</span>
  <span class="nn">MyValue</span><span class="p">::</span><span class="nf">Int</span><span class="p">(</span><span class="k">ref</span> <span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
  <span class="nn">MyValue</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="k">ref</span> <span class="n">s</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>        </div>
        <p>Here, <code class="highlighter-rouge">MyValue</code> is the sum type name, and <code class="highlighter-rouge">Int</code>/<code class="highlighter-rouge">String</code> are the branch names. By contrast, languages like <a href="https://ceylon-lang.org/documentation/tour/types/">Ceylon</a> have support for anonymous sum types:</p>
        <div class="language-ceylon highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ceylon
</span><span class="nd">HashMap</span><span class="o">&lt;</span><span class="nd">Integer</span><span class="o">,</span> <span class="nd">Integer</span><span class="o">|</span><span class="nd">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span>
    <span class="nd">HashMap</span> <span class="o">{</span> <span class="mi">100</span><span class="err">-</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">,</span> <span class="mi">200</span><span class="err">-</span><span class="o">&gt;</span><span class="s">"Hello world"</span> <span class="o">}</span>
</code></pre></div>        </div>
        <p>Most languages that have fully-featured sum types tend to only have named sums, one benefit being that it allows branches with the same inner type to have different names, e.g. <code class="highlighter-rouge">Foo(i32), Bar(i32)</code>.</p>
      </li>
      <li><strong>Declared vs. inferred</strong>: some languages with sum types like Rust require an explicit declaration of the enum ahead of time, as in the previous example. Other languages, like Ceylon as well as OCaml’s <a href="https://stackoverflow.com/questions/1428743/ocaml-list-that-could-contain-two-types">polymorphic variants</a> allow the sum types to be inferred by the compiler.
        <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* OCaml *)</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="nt">`Int</span> <span class="mi">0</span><span class="o">,</span> <span class="nt">`String</span> <span class="s2">"Hello world"</span><span class="p">]</span> <span class="p">;;</span>
<span class="c">(* l inferred to have type [ `Int of int | `String of string ] *)</span>
</code></pre></div>        </div>
      </li>
      <li><strong>Matched vs. casted</strong>: some languages like OCaml allow potentially incorrect casts from a sum type to one of its branches:
        <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* OCaml *)</span>
<span class="k">type</span> <span class="n">foo</span> <span class="o">=</span> <span class="nc">X</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Y</span> <span class="k">of</span> <span class="kt">string</span> <span class="p">;;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">X</span> <span class="mi">10</span> <span class="p">;;</span>
<span class="k">let</span> <span class="nc">X</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="p">;;</span> <span class="c">(* This raises an exception if incorrect *)</span>
<span class="n">print_int</span> <span class="n">y</span> <span class="p">;;</span>
</code></pre></div>        </div>
        <p>By contrast, Rust (and I believe Haskell?) require exhaustive matching:</p>
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">let</span> <span class="nn">MyValue</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="k">ref</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="o">&amp;</span><span class="mi">200</span><span class="p">];</span> <span class="c">// Invalid!</span>
</code></pre></div>        </div>
      </li>
    </ol>

    <p>There’s a surprisingly large design space here, and the pros/cons relative to dynamic languages vary based on the particular choices a language makes. Casted, inferred, and anonymous sums arguably come quite close to equivalent dynamic code, although such a type system appears uncommon in practice.</p>
  </li>
</ol>

<p>Among these many cases, implementing a heterogeneous data structures in a static language generally gives rise to two kinds of conceptual impedance mismatch:</p>
<ol>
  <li>The programmer either cannot easily encode the desired heterogeneity in a particular static language, e.g. OCaml does not provide a simple solution for an <code class="highlighter-rouge">Any</code> type.</li>
  <li>The programmer must decide too early (i.e. while initially describing the data structure) what kind of data types are allowed, e.g. in the enum case, or what functionality of the data types is allowed, e.g. in the traits case.</li>
</ol>

<p>By contrast, using a dynamic language like Python, you do not have to think about whether your data structures are polymorphic or not–you simply <em>get it for free</em>, no opinions necessary.</p>

<h2 id="2-ad-hoc-interfaces">2. Ad-hoc interfaces</h2>

<p>When writing polymorphic functions, i.e. functions that could apply to many different types, it’s common to specify a function over types that provide a specific set of functionality. For example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Python</span>
<span class="k">def</span> <span class="nf">print_list</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">formatted_elements</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'[{}]'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">','</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formatted_elements</span><span class="p">)))</span>
</code></pre></div></div>

<p>This function is implicitly defined over all lists (or technically iterables) that contain elements which can be converted to a string, using <code class="highlighter-rouge">str</code>. (This idea is also called “duck typing”, although I never found the term very informative.)</p>

<p>In a static language, all variables (including function arguments) must have known types at compile time. But what should the type of <code class="highlighter-rouge">l</code> be in the above example? How we write down that type depends on the facilities of the type system.</p>

<ol>
  <li><strong>Subtype polymorphism:</strong> if a base class contains all the functionality necessary for a generic function, then the concrete input type can be the base class. In Java, the <code class="highlighter-rouge">Object</code> class has a <code class="highlighter-rouge">toString</code> method, so this could be defined as:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Java</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">printList</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// l[0].toString() is valid</span>
  <span class="o">..</span>
<span class="o">}</span>

<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span>
<span class="n">l</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="n">Object</span><span class="o">)</span> <span class="mi">0</span><span class="o">);</span>
<span class="n">l</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="n">Object</span><span class="o">)</span> <span class="s">"Hello world"</span><span class="o">);</span>
<span class="n">printList</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
</code></pre></div>    </div>
    <p><strong>Pros:</strong> low syntactic overhead, flexible (no fixed set of types at implementation time). <br />
<strong>Cons:</strong> any object must be an instance of a class which derives from the required base class, which gets awkward/unwieldy for ad-hoc combinations of different methods. Interface must be explicitly specified in a class definition/interface.</p>
  </li>
  <li><strong>Trait polymorphism:</strong> this is basically the prime use case for traits, e.g. in Rust:
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">trait</span> <span class="n">ToString</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span> <span class="p">}</span>

<span class="k">fn</span> <span class="nf">print_list</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">impl</span> <span class="n">ToString</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// l[0].to_string() is valid</span>
  <span class="o">..</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">l1</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"Hello world"</span><span class="p">]</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="nf">print_list</span><span class="p">(</span><span class="n">l1</span><span class="p">);</span>

<span class="c">// impl ToString approach doesn't allow mixed-type containers</span>
<span class="k">let</span> <span class="n">l2</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ToString</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"hi"</span><span class="p">),</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)];</span>
<span class="nf">print_list</span><span class="p">(</span><span class="n">l2</span><span class="p">);</span> <span class="c">// Error! Box&lt;ToString&gt; isn't impl ToString (confusingly?)</span>

<span class="k">fn</span> <span class="nf">print_list</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ToString</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// l[0].to_string() is valid</span>
  <span class="o">..</span>
<span class="p">}</span>

<span class="nf">print_list</span><span class="p">(</span><span class="n">l2</span><span class="p">);</span> <span class="c">// Now it works</span>
</code></pre></div>    </div>
    <p><strong>Pros:</strong> zero syntactic/performance overhead in <code class="highlighter-rouge">impl Trait</code> case, logic is type-checked when implemented, not when used (e.g. a bug in <code class="highlighter-rouge">print_list</code> will be caught when the function is written).<br />
<strong>Cons:</strong> different syntaxes/APIs for homogeneous vs. heterogeneous data structures (i.e. static vs. dynamic dispatch). Interface must be explicitly specified in a trait.</p>
  </li>
  <li><strong><a href="http://www.cplusplus.com/doc/oldtutorial/templates/">Compile-time metaprogramming</a>:</strong> if a language supports staging like C++ with templates, then one can write:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C++</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print_list</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// l[0].to_string() is POSSIBLY valid</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">()</span> <span class="p">{</span> <span class="p">..</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo</span><span class="p">());</span>
<span class="n">print_list</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// No to_string() method</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Bar</span><span class="p">());</span>
<span class="n">print_list</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="c1">// Error! to_string() method is not defined on Bar</span>
</code></pre></div>    </div>
    <p><strong>Pros:</strong> no explicit interface must be defined (entirely ad-hoc).<br />
<strong>Cons:</strong> type-checking occurs when the API is used, not when it is defined (and compiler errors are forced to expose API implementation details). Does not allow polymorphic containers (<code class="highlighter-rouge">T</code> must be a concrete type like <code class="highlighter-rouge">Foo</code>, not like <code class="highlighter-rouge">impl ToString</code>). Also, template errors suck.</p>
  </li>
</ol>

<p>For static languages that support traits/typeclasses, the only overhead versus ad-hoc interfaces in dynamic languages is the verbosity of writing down the explicit interface and the type system complexity of parameterizing types by the interface. Not perfect, but not too bad. The bigger issue is that this mental model of the world naturally views the world compositionally, i.e. where any given type’s methods are built from many smaller traits, as opposed to hierarchically, where a type’s methods are derived from a class inheritance tree. If a programmer wants to write an ad-hoc interface in an object-oriented language, she must change her natural mental model of the program into the hierarchy required by the language, a clear conceptual impedance mismatch.</p>

<h2 id="3-reflection">3. Reflection</h2>

<p>A fairly unique feature of dynamic languages is that the entire language stack is usually available at runtime, e.g. it’s trivially easy to parse/translate/execute new code at runtime as well as to inspect/analyze language constructs like class members (the latter process is generally called “reflection”). This contrasts with compiled languages like C which produce standalone binaries that run outside the context of the compiler’s runtime.</p>

<p>In the Python ecosystem, for example, reflection is used to <a href="https://docs.python.org/3/library/pickle.html">serialize arbitrary objects</a>, <a href="https://docs.djangoproject.com/en/2.0/topics/db/models/">generate SQL tables from class definitions</a>, and <a href="https://docs.python.org/3/library/dataclasses.html">create comparison and equality checks</a>. Importantly, all of these tasks are accomplished by simple, intra-linguistic mechanisms, i.e. all you need is a Python interpreter to use these libraries. No additional parsers, AST libraries, etc. need to be downloaded or run external to the language runtime. For example, to print out all the methods of a class:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Python</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">Foo</span><span class="p">(),</span> <span class="n">predicate</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">))</span>
<span class="c"># [('bar', &lt;bound method Foo.bar of &lt;__main__.Foo object at 0x10320f0b8&gt;&gt;)]</span>
</code></pre></div></div>

<p>In static languages with limited or zero reflection, these tasks are instead performed by metaprogramming mechanisms. In Java for example, tools like IDEs are frequently used to code generate class definitions, getter/setter methods, and more. Other static languages use programmable macro systems to define a code generation pre-compilation step, e.g. the C preprocessor for C/C++, <code class="highlighter-rouge">macro_rules</code>/procedural macros for Rust, PPX for OCaml, and Template Haskell for Haskell. For example, to create a default method for turning an object into a string for debugging in Rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
  <span class="n">y</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="c">// ^ this compiles into something like:</span>
<span class="k">impl</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">debug</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"({}, {})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can implement a custom derive pass yourself, although the API is pretty rough (<a href="https://github.com/dtolnay/syn/blob/master/examples/heapsize/heapsize_derive/src/lib.rs">see an example</a>) compared to Python’s, and it’s not accessible at runtime, only compile time. In particular, macro systems are of wildly varying quality and flexibility, with some static languages lacking any macro system or reflection entirely.</p>

<p>Here, the core impedance mismatch is that metaprogramming is fundamentally at odds with static typing. It’s simply difficult to express reflective language constructs in a verifiably safe manner. Type-safe metaprogramming has been the subject of decades of research in the academic programming languages community (e.g. <a href="https://www.sciencedirect.com/science/article/pii/S0304397500000530">MetaML</a>, <a href="https://scala-lms.github.io/">Scala LMS</a>), and no clear system has emerged as the “right way” to do it. Compiled languages (and subsequently most static languages) seem empirically averse to exposing any compiler internals like tokens, syntax trees, types, etc. to the language runtime, although the tide is slowly changing in that direction.</p>

<h2 id="4-exceptions">4. Exceptions</h2>

<p>Exceptions are a mechanism that allow non-local control flow, jumping from an raised exception to the closest catch on the call stack. Exceptions are not unique to dynamic languages—bog-standard languages like Java, niche functional languages like OCaml, and even systems languages like C++ support exceptions.<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p>

<p>Exceptions are still worth talking about because not all static languages have them, and it’s important to understand how critical they are to the dynamic programming style. Generally speaking, much of the productivity gain of dynamic languages could boil down to “not forcing the programmer to think about an issue until it arises,” or in the Python community, “it’s better to ask forgiveness than permission.” For example, in the following snippet:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Python</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'test.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">10</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</code></pre></div></div>

<p>If I execute this program, it could fail with:</p>
<ol>
  <li>A <code class="highlighter-rouge">FileNotFoundError</code> if <code class="highlighter-rouge">test.txt</code> doesn’t exist,</li>
  <li>A <code class="highlighter-rouge">ValueError</code> if the contents of <code class="highlighter-rouge">test.txt</code> can’t be interpreted as an integer, or</li>
  <li>A <code class="highlighter-rouge">ZeroDivisionError</code> if <code class="highlighter-rouge">int(s) == 0</code>.</li>
</ol>

<p>However, assuming I set everything up correctly, I don’t have to think about any of those edge cases until they occur. By contrast, a language like Rust chooses to encode many of these cases in the type system such that the programmer is forced to handle possible errors:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"File not found"</span><span class="p">);</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">contents</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">contents</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Failed to read"</span><span class="p">);</span>
<span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">contents</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Failed to become int"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">n</span> / <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>All of those <code class="highlighter-rouge">expect</code> calls are saying “if this operation failed, then abort the program, otherwise get the function’s output.” (See <a href="https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html">The Book</a> for more on error handling in Rust, and how this could be made more concise.) This sort of pattern is common in languages like Haskell (but with monads) and OCaml (although the exceptions vs. monads debate is more fiery there).</p>

<p>There’s also the “error code” approach that C, Go, and sometimes Java adopt where calling a function returns both a possible pointer to the value and an error object, e.g.:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Go</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">CopyFile</span><span class="p">(</span><span class="n">dstName</span><span class="p">,</span><span class="x"> </span><span class="n">srcName</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="n">written</span><span class="x"> </span><span class="kt">int64</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">src</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">srcName</span><span class="p">)</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">dst</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">dstName</span><span class="p">)</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">written</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="x"> </span><span class="n">src</span><span class="p">)</span><span class="x">
    </span><span class="n">dst</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">
    </span><span class="n">src</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">
    </span><span class="k">return</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>While you could theoretically ignore the errors and program as if they didn’t exist, this style of programming seems strictly worse compared to either exceptions or result types, since both approaches both require that an error be handled, not letting a user attempt to perform operations on an invalid handle to an object.</p>

<p>Exceptions are also a good example of how the dynamic feel of a language comes from not just making it <em>possible</em> to express certain idioms in your type system, but <em>pervasively adopting</em> these idioms across the standard libraries. Even if exceptions were added to Rust today, there’s no chance that the standard library would be changed from result types to exceptions in cases of failure, which means that a new programmer in Rust would never feel the benefits of exceptions barring how they use them in their own code. When your type system permits different sets of opinions and the canonical APIs all have different opinions than you, there’s simply no recourse.</p>

<h2 id="5-partial-programs">5. Partial programs</h2>

<p>During the process of developing a program, it’s often in an incomplete or inconsistent state. A programmer naturally develops a program one piece at a time, leaving the other pieces as stubs or comments. For example, if I wrote a program to divide each element of a list by a number, that might start like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Python</span>
<span class="k">def</span> <span class="nf">divide_list</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># do something?</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">/</span> <span class="n">n</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">divide_list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>This works fine. I want to remember to hit the <code class="highlighter-rouge">n = 0</code> edge case later, but don’t want to implement the error handling logic quite yet.  However, if I wrote the same program in a static language like Rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">fn</span> <span class="nf">divide_list</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c">// do something?</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">l</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="err">/</span> <span class="n">n</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then this fails with a compile error:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0308]: mismatched types
 --&gt; test.rs:2:13
  |
2 |     if n == 0 {
  |  _____________^
3 | |     // do something?
4 | |   } else {
  | |___^ expected struct `std::vec::Vec`, found ()
  |
  = note: expected type `std::vec::Vec&lt;i32&gt;`
             found type `()`
</code></pre></div></div>

<p>The issue here is that the compiler requires that all values have a provably consistent type at compile time. Here, if the first if branch doesn’t also return a vector, then the type checker cannot say the function reliably returns a vector, a fair statement. However, this forces the programmer to add extra code to satisfy the type checker while iterating. In Rust, the simplest approach is to use the <a href="https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#the--never-type-that-never-returns"><code class="highlighter-rouge">!</code> type</a>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">fn</span> <span class="nf">divide_list</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c">// do something?</span>
    <span class="k">return</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Divide by zero"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">l</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="err">/</span> <span class="n">n</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is similar to how exceptions are type-checked in a language like OCaml, i.e. the language has a type which is considered a valid replacement (or subtype) for any other type.</p>

<p>More broadly, it is generally true that any static analysis tool, like a type checker (as in all static languages) or a borrow checker (as in Rust), requires a complete knowledge of types/lifetimes/etc. after analysis of a program, either via explicit annotation or inference<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>. In Rust, if I write:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Rust</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then this fails with the error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0282]: type annotations needed
 --&gt; test.rs:2:19
  |
2 |   let v: Vec&lt;_&gt; = Vec::new();
  |       -           ^^^^^^^^^^ cannot infer type for `T`
  |       |
  |       consider giving `v` a type
  |
</code></pre></div></div>

<p>Most type checkers would not, for example, decide <code class="highlighter-rouge">T = Any</code> and then insert runtime type checks any time a value from <code class="highlighter-rouge">v</code> was used. This is again an example of requiring a programmer to make decisions about the types of variables before it is necessary due to restrictions of the type system. Partial programs are not easily amenable to static analysis.</p>

<h2 id="discussion">Discussion</h2>

<p>Across these examples, the conceptual impedance mismatch generally appears in two ways:</p>

<ol>
  <li>
    <p><em class="hl">The programmer cannot naturally express a program construct that can be statically verified by the type system.</em> Heterogenous data structures in OCaml, ad-hoc interfaces in Java, reflection in C, exceptions in Rust, all of these are examples of programming constructs a programmer might naturally seek to best express a domain concept, but would lack in the target language.</p>
  </li>
  <li>
    <p><em class="hl">The programmer has a fuzzy idea about the structure of a program, but is forced to reify program details unrelated to her current focus.</em> Mandatory typing partial programs, required handling of edge cases instead of exceptions, both of these cases are examples of a program’s static guarantees requiring more information from a programmer during the development phase than she wants to give at a particular point in time.</p>
  </li>
</ol>

<p>I’m not trying to pass a value judgment on whether these are trends are intrinsically good or bad. Forcing programmers to not only think about edge cases but clearly expose them in the type system is part of the Rust experience, dictated by a culture of safety (since, after all, <a href="https://graydon2.dreamwidth.org/247406.html">Rust is mostly safety</a>). Dynamic languages are notoriously error-prone, difficult to refactor, etc. along with the the host of other pro-static-typing arguments.</p>

<p>However, I think we need a more nuanced understanding of both how programmers think about programming as well as how dynamic languages mesh with that process. This can lead us to a more sensible discussion about the tradeoffs between static and dynamic languages, and it can help us design better metrics for evaluating the human impact of language features and tooling.</p>

<p>But, of course, this is all just from my personal experience. Do you find dynamic languages more productive, and if so, why? Please send me mail at <a href="mailto:wcrichto@cs.stanford.edu">wcrichto@cs.stanford.edu</a> or leave a comment on <a href="https://news.ycombinator.com/item?id=17439635">Hacker News</a>.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>I’m using “dynamic language” roughly as short-hand for “dynamically-typed language,” but also to convey a more general sentiment about the feel of a language rather than simply a feature of the type system. A “static language” will be any language that’s not a dynamic language. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Although I’m to understand that exceptions in C++ are generally frowned upon? <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>There’s some cool research out there about languages, runtimes, and IDEs that support typed holes, e.g. see <a href="http://hazel.org/">Hazel</a> and <a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#holes">Idris</a>. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-16662292-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-16662292-3');
    </script>
  </body>
</html>
